<html style="" lang="en" class="js flexbox fontface"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><meta content="OCaml Scientific and Engineering Computing - Tutorial Book" name="description"><meta content="OCaml, Data Science, Data Analytics, Analytics, Functional Programming, Machine Learning, Deep Neural Network, Scientific Computing, Numerical Algorithm, Tutorial, Linear Algebra, Matrix" name="keywords"><meta content="Liang Wang" name="author"><title>Conventions - OCaml Scientific Computing Tutorials</title><link href="css/app.css" rel="stylesheet"><link href="css/prism.css" rel="stylesheet"><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="https://use.typekit.net/gfj8wez.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>try{Typekit.load();}catch(e){}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-123353217-1');</script></head><body><div class="title-bar"><div class="title"><h1>OCaml Scientific Computing Tutorials</h1><h5></h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="https://ocaml.xyz/api/">API</a><a href="../index.html">英文版</a></nav></div></div><div class="wrap"><div class="left-column"><a class="to-chapter" href="toc.html"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body"><section class="level1" id="conventions">
<h1>约定</h1>
<p>每个软件系统都有其自己的规则和约定，需要开发人员遵守。Owl 不例外，例如<a href="broadcast.html">广播操作规则</a>和<a href="slicing.html">切片定义约定</a>。在本章中，我将涵盖 Owl 中的函数命名和各种约定。</p>
<section class="level2" id="pure-vs.-impure">
<h2>纯 vs. 非纯</h2>
<p><code>Ndarray</code> 模块包含许多用于操作和执行多维数组的数学运算的函数。 <strong>纯函数</strong>（也称为不可变函数）是指那些不修改传入变量但始终返回新变量作为结果的函数。相比之下，<strong>非纯函数</strong>（也称为可变函数）是指那些在原地修改传入变量的函数。</p>
<p>关于纯函数和非纯函数之间的争论永远不会结束。通常，函数式编程倡导使用不可变数据结构。使用非纯函数使得难以推理代码的正确性，因此在决定使用它们时需要仔细考虑。另一方面，仅因为修改了一个元素就每次生成一个新的 <code>1000 x 1000</code> 矩阵似乎也不太实际。</p>
<p>Owl 引入非纯函数是经过许多慎重和实际的考虑的。使用原地修改的主要动机之一是避免昂贵的内存分配和释放操作，这可以在大型 ndarray 和矩阵涉及时显着提高数值应用程序的运行时性能。</p>
<p>我们是否可以拥有两全其美的最佳部分，即编写功能代码并同时在内存上高效？随着您对 Owl 的了解越来越多，您将意识到通过使用<a href="cgraph.html">计算图</a>懒惰地评估数学表达式，这是可以实现的。程序员关注功能代码，Owl 的计算图模块负责“危险任务”——高效地分配和管理内存。</p>
<p><code>Ndarray</code> 模块中的许多纯函数都有其相应的非纯版本，区别在于非纯版本的函数名称末尾有一个额外的下划线 “<code>_</code>”。例如，以下函数是 <code>Arr</code> 模块中的纯函数。</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Arr.sin;;
  Arr.cos;;
  Arr.log;;
  Arr.abs;;
  Arr.add;;
  Arr.mul;;
</code></pre>
</div>
<p>它们对应的非纯函数如下。</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Arr.sin_;;
  Arr.cos_;;
  Arr.log_;;
  Arr.abs_;;
  Arr.add_;;
  Arr.mul_;;
</code></pre>
</div>
<p>对于<code>Arr.sin x</code>等一元运算符，情况相当直接，<code>x</code> 将在原地修改。但是，对于<code>Arr.add_scalar_ x a</code>和<code>Arr.add_ x y</code>等二元运算符，情况需要一些澄清。对于<code>Arr.add_scalar x a</code>，<code>x</code> 将在原地修改并存储最终结果，这是微不足道的，因为<code>a</code>是标量。</p>
<p>对于<code>Arr.add_ x y</code>，问题是在两个输入都是 ndarray 时存储最终结果的位置。让我们看一下<code>Arr.add_</code>函数的类型。</p>
<div class="highlight">
<pre><code class="language-text">val Arr.add_ : ?out:Arr.arr -&gt; Arr.arr -&gt; Arr.arr -&gt; unit</code></pre>
</div>
<p>从函数类型中可以看出，输出可以由可选的 <code>out</code> 参数指定。如果输入中缺少 <code>out</code>，那么 Owl 将尝试使用第一个操作数（即 <code>x</code>）来存储最终结果。因为 Owl 中的二元操作符默认支持广播操作，这进一步说明了在使用非纯函数时，第一个参数 <code>x</code> 的每个维度都不能小于第二个参数 <code>y</code> 的相应维度。换句话说，非纯函数只允许将较小的 <code>y</code> 广播到足够大以容纳结果的 <code>x</code>。</p>
<p>Owl 中的大多数二元数学函数都与一个简写操作符相关，例如<code>+</code>，<code>-</code>，<code>*</code>和<code>/</code>。非纯版本也有它们自己的操作符。例如，与<code>Arr.(x + y)</code>对应，它返回一个新的 ndarray 中的结果，您可以编写<code>Arr.(x += y)</code>，该操作将<code>x</code>和<code>y</code>相加并将结果保存到<code>x</code>中。</p>
<table style="width:71%;">
<caption>纯和非纯二元数学函数的别名 {#tbl:convention:pure}</caption>
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数名</th>
<th style="text-align: left;">纯</th>
<th style="text-align: left;">非纯</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">add</td>
<td style="text-align: left;"><code>+</code></td>
<td style="text-align: left;"><code>+=</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">sub</td>
<td style="text-align: left;"><code>-</code></td>
<td style="text-align: left;"><code>-=</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">mul</td>
<td style="text-align: left;"><code>*</code></td>
<td style="text-align: left;"><code>*=</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">div</td>
<td style="text-align: left;"><code>/</code></td>
<td style="text-align: left;"><code>/=</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">add_scalar</td>
<td style="text-align: left;"><code>+$</code></td>
<td style="text-align: left;"><code>+$=</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">sub_scalar</td>
<td style="text-align: left;"><code>-$</code></td>
<td style="text-align: left;"><code>-$=</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">mul_scalar</td>
<td style="text-align: left;"><code>*$</code></td>
<td style="text-align: left;"><code>*$=</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">div_scalar</td>
<td style="text-align: left;"><code>/$</code></td>
<td style="text-align: left;"><code>/$=</code></td>
</tr>
</tbody>
</table>
</section>

<section class="level2" id="ndarray-vs.-scalar">
  <h2>Ndarray vs.&nbsp;Scalar</h2>
  <p>有三种类型的 ndarray 操作：<em>map</em>、<em>scan</em> 和 <em>reduce</em>。许多函数可以归类为减少操作，例如 <code>Arr.sum</code>、<code>Arr.prod</code>、<code>Arr.min</code>、<code>Arr.mean</code>、<code>Arr.std</code> 等。Owl 中的所有减少函数都有一个名为 <code>axis</code> 的参数。当在多维数组上应用这些减少操作时，有两种可能的情况：</p>
  <ul>
  <li>如果明确指定了轴，则 Owl 沿指定的轴减少；</li>
  <li>如果未指定轴，则 Owl 首先将 ndarray 扁平化为矢量，然后沿轴 0 减少所有元素。</li>
  </ul>
  <p>如果传入的 ndarray 已经是一维的，则这两种情况是等效的。在以下代码片段中，<code>a</code> 的形状为 <code>[|3;1;3|]</code>，而 <code>b</code> 的形状为 <code>[|1|]</code>，因为它只包含一个元素。</p>
  <div class="highlight">
  <pre><code class="language-ocaml">
    let x = Arr.sequential [|3;3;3|];;
    let a = Arr.sum ~axis:1 x;;
    let b = Arr.sum x;;
  </code></pre>
  </div>
  <p>如果您想将 <code>b</code> 中的结果与另一个浮点数相加，您需要通过调用 <code>get</code> 函数检索该值。</p>
  <div class="highlight">
  <pre><code class="language-ocaml">
    let c = Arr.get b [|0|] in
    c +. 10.;;
  </code></pre>
  </div>
  <p>如果我们总是需要从减少操作的返回值中提取标量值，这看起来并不太方便。对于像 Python 和 Julia 这样的语言来说，这不是问题，因为返回类型是动态确定的。但是，对于 OCaml，这变得具有挑战性：我们要么使用统一的类型，要么实现另一组函数。最终，我们在 Owl 的设计中选择了后者。每个减少操作都有两个版本：</p>
  <ul>
  <li>一个允许您沿指定轴减少或减少所有元素，但始终返回一个 ndarray；</li>
  <li>一个仅减少所有元素并始终返回标量值。</li>
  </ul>
  <p>两者之间的区别在于返回标量的函数的名称末尾带有额外的撇号 “<code>'</code>” 字符。例如，对于返回 ndarray 的第一种函数类型，它们的函数名称看起来像这样。</p>
  <div class="highlight">
  <pre><code class="language-ocaml">
    Arr.sum;;
    Arr.min;;
    Arr.prod;;
    Arr.mean;;
    Arr.std;;
  </code></pre>
  </div>
  <p>对于返回标量的第二种函数类型，它们的名称看起来像这样。</p>
  <div class="highlight">
  <pre><code class="language-ocaml">
    Arr.sum';;
    Arr.min';;
    Arr.prod';;
    Arr.mean';;
    Arr.std';;
  </code></pre>
  </div>
  <p>从技术上讲，<code>Arr.sum'</code> 等效于以下代码。</p>
  <div class="highlight">
  <pre><code class="language-ocaml">
    let sum' x =
      let y = Arr.sum x in
      Arr.get y [|0|]
  </code></pre>
  </div>
  <p>让我们扩展上一个代码片段，并在 OCaml 的 toplevel 中测试它。然后您将立即了解到两者之间的区别。</p>
  <div class="highlight">
  <pre><code class="language-ocaml">
    let x = Arr.sequential [|3;3;3|];;
    let a = Arr.sum ~axis:1 x;;
    let b = Arr.sum x;;
    let c = Arr.sum' x;;
  </code></pre>
  </div>
  <p>规则和约定通常揭示了设计中的权衡。通过澄清限制，我们希望程序员能够在特定情境中选择正确的函数使用。</p>
  </section>
  <section class="level2" id="infix-operators">
  <h2>Infix Operators</h2>
  <p>Owl 中的运算符是在 <code>Owl_operator</code> 模块中定义的函数子中实现的。这些运算符分为 <code>Basic</code>、<code>Extend</code>、<code>Matrix</code> 和 <code>Ndarray</code> 四个模块类型签名，因为某些操作仅对特定的数据结构有意义。例如，矩阵乘法 <code>*@</code> 仅在 <code>Matrix</code> 签名中定义。</p>
  <p>只要模块实现了模块签名中定义的所有函数，您就可以使用这些函数子生成相应的运算符。在大多数情况下，您不需要直接使用这些函数子在 Owl 中工作，因为我已经为您完成了生成部分。</p>
  <p>这些运算符已经包含在每个 <code>Ndarray</code> 和 <code>Matrix</code> 模块中。以下表总结了当前实现的运算符。在表中，<code>x</code> 和 <code>y</code> 都表示矩阵或 ndarray，而 <code>a</code> 表示标量值。</p>
  <table>
  
<caption>Infix operators in ndarray and matrix modules {#tbl:convention:infix}</caption>
<colgroup>
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 30%">
<col style="width: 16%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Operator</th>
<th style="text-align: left;">Example</th>
<th style="text-align: left;">Operation</th>
<th>Dense/Sparse</th>
<th style="text-align: left;">Ndarray/Matrix</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>+</code></td>
<td style="text-align: left;"><code>x + y</code></td>
<td style="text-align: left;">element-wise add</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-</code></td>
<td style="text-align: left;"><code>x - y</code></td>
<td style="text-align: left;">element-wise sub</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>*</code></td>
<td style="text-align: left;"><code>x * y</code></td>
<td style="text-align: left;">element-wise mul</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>/</code></td>
<td style="text-align: left;"><code>x / y</code></td>
<td style="text-align: left;">element-wise div</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>+$</code></td>
<td style="text-align: left;"><code>x +$ a</code></td>
<td style="text-align: left;">add scalar</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-$</code></td>
<td style="text-align: left;"><code>x -$ a</code></td>
<td style="text-align: left;">sub scalar</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>*$</code></td>
<td style="text-align: left;"><code>x *$ a</code></td>
<td style="text-align: left;">mul scalar</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>/$</code></td>
<td style="text-align: left;"><code>x /$ a</code></td>
<td style="text-align: left;">div scalar</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>$+</code></td>
<td style="text-align: left;"><code>a $+ x</code></td>
<td style="text-align: left;">scalar add</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>$-</code></td>
<td style="text-align: left;"><code>a $- x</code></td>
<td style="text-align: left;">scalar sub</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>$*</code></td>
<td style="text-align: left;"><code>a $* x</code></td>
<td style="text-align: left;">scalar mul</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>$/</code></td>
<td style="text-align: left;"><code>a $/ x</code></td>
<td style="text-align: left;">scalar div</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>=</code></td>
<td style="text-align: left;"><code>x = y</code></td>
<td style="text-align: left;">comparison</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>!=</code></td>
<td style="text-align: left;"><code>x != y</code></td>
<td style="text-align: left;">comparison</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;&gt;</code></td>
<td style="text-align: left;"><code>x &lt;&gt; y</code></td>
<td style="text-align: left;">same as <code>!=</code></td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;</code></td>
<td style="text-align: left;"><code>x &gt; y</code></td>
<td style="text-align: left;">comparison</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;</code></td>
<td style="text-align: left;"><code>x &lt; y</code></td>
<td style="text-align: left;">comparison</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;=</code></td>
<td style="text-align: left;"><code>x &gt;= y</code></td>
<td style="text-align: left;">comparison</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;=</code></td>
<td style="text-align: left;"><code>x &lt;= y</code></td>
<td style="text-align: left;">comparison</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>=.</code></td>
<td style="text-align: left;"><code>x =. y</code></td>
<td style="text-align: left;">element-wise cmp</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>!=.</code></td>
<td style="text-align: left;"><code>x !=. y</code></td>
<td style="text-align: left;">element-wise cmp</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&lt;&gt;.</code></td>
<td style="text-align: left;"><code>x &lt;&gt;. y</code></td>
<td style="text-align: left;">same as <code>!=.</code></td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&gt;.</code></td>
<td style="text-align: left;"><code>x &gt;. y</code></td>
<td style="text-align: left;">element-wise cmp</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&lt;.</code></td>
<td style="text-align: left;"><code>x &lt;. y</code></td>
<td style="text-align: left;">element-wise cmp</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&gt;=.</code></td>
<td style="text-align: left;"><code>x &gt;=. y</code></td>
<td style="text-align: left;">element-wise cmp</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&lt;=.</code></td>
<td style="text-align: left;"><code>x &lt;=. y</code></td>
<td style="text-align: left;">element-wise cmp</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>=$</code></td>
<td style="text-align: left;"><code>x =$ y</code></td>
<td style="text-align: left;">comp to scalar</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>!=$</code></td>
<td style="text-align: left;"><code>x !=$ y</code></td>
<td style="text-align: left;">comp to scalar</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;&gt;$</code></td>
<td style="text-align: left;"><code>x &lt;&gt;$ y</code></td>
<td style="text-align: left;">same as <code>!=</code></td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;$</code></td>
<td style="text-align: left;"><code>x &gt;$ y</code></td>
<td style="text-align: left;">compare to scalar</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;$</code></td>
<td style="text-align: left;"><code>x &lt;$ y</code></td>
<td style="text-align: left;">compare to scalar</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;=$</code></td>
<td style="text-align: left;"><code>x &gt;=$ y</code></td>
<td style="text-align: left;">compare to scalar</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;=$</code></td>
<td style="text-align: left;"><code>x &lt;=$ y</code></td>
<td style="text-align: left;">compare to scalar</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>=.$</code></td>
<td style="text-align: left;"><code>x =.$ y</code></td>
<td style="text-align: left;">element-wise cmp</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>!=.$</code></td>
<td style="text-align: left;"><code>x !=.$ y</code></td>
<td style="text-align: left;">element-wise cmp</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&lt;&gt;.$</code></td>
<td style="text-align: left;"><code>x &lt;&gt;.$ y</code></td>
<td style="text-align: left;">same as <code>!=.$</code></td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&gt;.$</code></td>
<td style="text-align: left;"><code>x &gt;.$ y</code></td>
<td style="text-align: left;">element-wise cmp</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&lt;.$</code></td>
<td style="text-align: left;"><code>x &lt;.$ y</code></td>
<td style="text-align: left;">element-wise cmp</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&gt;=.$</code></td>
<td style="text-align: left;"><code>x &gt;=.$ y</code></td>
<td style="text-align: left;">element-wise cmp</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&lt;=.$</code></td>
<td style="text-align: left;"><code>x &lt;=.$ y</code></td>
<td style="text-align: left;">element-wise cmp</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>=~</code></td>
<td style="text-align: left;"><code>x =~ y</code></td>
<td style="text-align: left;">approx <code>=</code></td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>=~$</code></td>
<td style="text-align: left;"><code>x =~$ y</code></td>
<td style="text-align: left;">approx <code>=$</code></td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>=~.</code></td>
<td style="text-align: left;"><code>x =~. y</code></td>
<td style="text-align: left;">approx <code>=.</code></td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>=~.$</code></td>
<td style="text-align: left;"><code>x =~.$ y</code></td>
<td style="text-align: left;">approx <code>=.$</code></td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%</code></td>
<td style="text-align: left;"><code>x % y</code></td>
<td style="text-align: left;">mod divide</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%$</code></td>
<td style="text-align: left;"><code>x %$ a</code></td>
<td style="text-align: left;">mod divide scalar</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>**</code></td>
<td style="text-align: left;"><code>x ** y</code></td>
<td style="text-align: left;">power function</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>*@</code></td>
<td style="text-align: left;"><code>x *@ y</code></td>
<td style="text-align: left;">matrix multiply</td>
<td>both</td>
<td style="text-align: left;">Matrix</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>/@</code></td>
<td style="text-align: left;"><code>x /@ y</code></td>
<td style="text-align: left;">solve linear system</td>
<td>both</td>
<td style="text-align: left;">Matrix</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>**@</code></td>
<td style="text-align: left;"><code>x **@ a</code></td>
<td style="text-align: left;">matrix power</td>
<td>both</td>
<td style="text-align: left;">Matrix</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>min2</code></td>
<td style="text-align: left;"><code>min2 x y</code></td>
<td style="text-align: left;">element-wise min</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>max2</code></td>
<td style="text-align: left;"><code>max2 x y</code></td>
<td style="text-align: left;">element-wise max</td>
<td>both</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>@=</code></td>
<td style="text-align: left;"><code>x @= y</code></td>
<td style="text-align: left;">concatenate vertically</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>@||</code></td>
<td style="text-align: left;"><code>x @|| y</code></td>
<td style="text-align: left;">concatenate horizontally</td>
<td>Dense</td>
<td style="text-align: left;">both</td>
</tr>
</tbody>
</table>
<p>以下是值得注意的一些事项。</p>
<ul>
<li><p><code>*</code> 用于逐元素相乘；<code>*@</code> 用于矩阵相乘。如果阅读 <a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/optimise/owl_algodiff_generic.ml">Algodiff</a> 模块的源代码，您可以轻松理解为什么使用 <code>*</code> 进行逐元素相乘（对于矩阵）导致了一致的算法导数实现。</p></li>
<li><p><code>+$</code> 有其相应的运算符 <code>$+</code>，如果我们翻转参数的顺序。但是，请非常注意运算符的优先级，因为 OCaml 根据中缀的第一个字符确定优先级。 <code>+$</code> 保留优先级，而 <code>$+</code> 不保留。因此，我建议非常谨慎地使用 <code>$+</code>。请始终使用括号显式指定优先级。对于 <code>$-</code>、<code>$*</code> 和 <code>$/</code> 也是一样。</p></li>
<li><p>对于比较运算符，例如 <code>=</code> 和 <code>=.</code> 都比较两个变量 <code>x</code> 和 <code>y</code> 中的所有元素。区别在于 <code>=</code> 返回一个布尔值，而 <code>=.</code> 返回形状和类型与 <code>x</code> 和 <code>y</code> 相同的矩阵或 ndarray。在返回的结果中，如果 <code>x</code> 和 <code>y</code> 中相应位置的值满足谓词，则该位置的值为 <code>1</code>，否则为 <code>0</code>。</p></li>
<li><p>对于以 <code>$</code> 结尾的比较运算符，它们用于将矩阵/ndarray 与标量值进行比较。</p></li>
</ul>
<p>运算符易于使用，以下是一些示例。</p>
<div class="highlight">
<pre><code class="language-ocaml">let x = Mat.uniform 5 5;;
let y = Mat.uniform 5 5;;

Mat.(x + y);;
Mat.(x * y);;
Mat.(x ** y);;
Mat.(x *@ y);;

(* 比较以下两个返回的结果 *)

Mat.(x &gt; y);;
Mat.(x &gt;. y);;</code></pre>
</div>
<p>以下是第一个示例的返回。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.(x &gt; y);;
&gt;- : bool = false
</code></pre>
</div>
<p>以下是第二个示例的返回。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.(x &gt;. y);;
&gt;- : (float, float64_elt) Owl_dense_matrix_generic.t =
&gt;
&gt;   C0 C1 C2 C3 C4
&gt;R0  0  1  1  0  1
&gt;R1  0  1  1  0  1
&gt;R2  0  0  0  0  0
&gt;R3  1  0  0  0  1
&gt;R4  0  1  0  0  1
</code></pre>
</div>
<p>现在我相信您已经了解了 <code>&gt;</code> 和 <code>&gt;.</code> 之间的区别，其他二进制比较运算符也是一样的。</p>
<p>请注意，上表未包含扩展的索引和切片运算符，但您可以在 <a href="slicing.html">索引和切片章节</a> 中找到详细说明。</p>
</section>
<section class="level2" id="operator-extension">
<h2>运算符扩展</h2>
<p>正如您所看到的，上面的运算符不允许在不同的数字类型之间进行互操作（实际上这可能并不是坏事）。例如，除非在 <code>Generic</code> 模块中显式调用 <code>cast</code> 函数，否则您不能将 <code>float32</code> 矩阵添加到 <code>float64</code> 矩阵。对于喜欢 Python 风格的人，<code>Owl.Ext</code> 模块专门为此目的而设计，以使原型制作更快、更容易。一旦打开模块，<code>Ext</code> 就会立即为您提供一组运算符，以便您可以在不同的数字类型上进行互操作，如下所示。如果需要，它会自动为您转换类型。</p>
<table style="width:86%;">

<caption>Operator extensions {#tbl:convention:ext}</caption>
<colgroup>
<col style="width: 23%">
<col style="width: 25%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Operator</th>
<th style="text-align: left;">Example</th>
<th style="text-align: left;">Operation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>+</code></td>
<td style="text-align: left;"><code>x + y</code></td>
<td style="text-align: left;">add</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-</code></td>
<td style="text-align: left;"><code>x - y</code></td>
<td style="text-align: left;">sub</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>*</code></td>
<td style="text-align: left;"><code>x * y</code></td>
<td style="text-align: left;">mul</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>/</code></td>
<td style="text-align: left;"><code>x / y</code></td>
<td style="text-align: left;">div</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>=</code></td>
<td style="text-align: left;"><code>x = y</code></td>
<td style="text-align: left;">comparison, return bool</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>!=</code></td>
<td style="text-align: left;"><code>x != y</code></td>
<td style="text-align: left;">comparison, return bool</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;&gt;</code></td>
<td style="text-align: left;"><code>x &lt;&gt; y</code></td>
<td style="text-align: left;">same as <code>!=</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;</code></td>
<td style="text-align: left;"><code>x &gt; y</code></td>
<td style="text-align: left;">comparison, return bool</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;</code></td>
<td style="text-align: left;"><code>x &lt; y</code></td>
<td style="text-align: left;">comparison, return bool</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;=</code></td>
<td style="text-align: left;"><code>x &gt;= y</code></td>
<td style="text-align: left;">comparison, return bool</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;=</code></td>
<td style="text-align: left;"><code>x &lt;= y</code></td>
<td style="text-align: left;">comparison, return bool</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>=.</code></td>
<td style="text-align: left;"><code>x =. y</code></td>
<td style="text-align: left;">element_wise comparison</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>!=.</code></td>
<td style="text-align: left;"><code>x !=. y</code></td>
<td style="text-align: left;">element_wise comparison</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&lt;&gt;.</code></td>
<td style="text-align: left;"><code>x &lt;&gt;. y</code></td>
<td style="text-align: left;">same as <code>!=.</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&gt;.</code></td>
<td style="text-align: left;"><code>x &gt;. y</code></td>
<td style="text-align: left;">element_wise comparison</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&lt;.</code></td>
<td style="text-align: left;"><code>x &lt;. y</code></td>
<td style="text-align: left;">element_wise comparison</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&gt;=.</code></td>
<td style="text-align: left;"><code>x &gt;=. y</code></td>
<td style="text-align: left;">element_wise comparison</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&lt;=.</code></td>
<td style="text-align: left;"><code>x &lt;=. y</code></td>
<td style="text-align: left;">element_wise comparison</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%</code></td>
<td style="text-align: left;"><code>x % y</code></td>
<td style="text-align: left;">element_wise mod divide</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>**</code></td>
<td style="text-align: left;"><code>x ** y</code></td>
<td style="text-align: left;">power function</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>*@</code></td>
<td style="text-align: left;"><code>x *@ y</code></td>
<td style="text-align: left;">matrix multiply</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>min2</code></td>
<td style="text-align: left;"><code>min2 x y</code></td>
<td style="text-align: left;">element-wise min</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>max2</code></td>
<td style="text-align: left;"><code>max2 x y</code></td>
<td style="text-align: left;">element-wise max</td>
</tr>
</tbody>
</table>
<p>您可能已经注意到，以 <code>$</code> 结尾的运算符（例如 <code>+$</code>、<code>-$</code> 等）在表中消失了，这仅仅是因为我们可以直接将标量与矩阵相加/相减/相乘/相除，因此不再需要这些运算符。对于比较运算符也是类似的，因为我们可以使用相同的 <code>&gt;</code> 运算符来比较矩阵与另一个矩阵，或者将矩阵与标量进行比较，因此我们不再需要 <code>&gt;$</code>。允许互操作使运算符表格变得更短。</p>
<p>目前，<code>Ext</code> 模块中的运算符仅支持密集结构上的互操作。除了二进制运算符之外，<code>Ext</code> 还实现了大多数常见的数学函数，这些函数可以应用于浮点数、复数、矩阵和 ndarray。这些函数包括：</p>
<p><code>im</code>、<code>re</code>、<code>conj</code>、<code>abs</code>、<code>abs2</code>、<code>neg</code>、<code>reci</code>、<code>signum</code>、<code>sqr</code>、<code>sqrt</code>、<code>cbrt</code>、<code>exp</code>、<code>exp2</code>、<code>expm1</code>、<code>log</code>、<code>log10</code>、<code>log2</code>、<code>log1p</code>、<code>sin</code>、<code>cos</code>、<code>tan</code>、<code>asin</code>、<code>acos</code>、<code>atan</code>、<code>sinh</code>、<code>cosh</code>、<code>tanh</code>、<code>asinh</code>、<code>acosh</code>、<code>atanh</code>、<code>floor</code>、<code>ceil</code>、<code>round</code>、<code>trunc</code>、<code>erf</code>、<code>erfc</code>、<code>logistic</code>、<code>relu</code>、<code>softplus</code>、<code>softsign</code>、<code>softmax</code>、<code>sigmoid</code>、<code>log_sum_exp</code>、<code>l1norm</code>、<code>l2norm</code>、<code>l2norm_sqr</code>、<code>inv</code>、<code>trace</code>、<code>sum</code>、<code>prod</code>、<code>min</code>、<code>max</code>、<code>minmax</code>、<code>min_i</code>、<code>max_i</code>、<code>minmax_i</code>。</p>
<p>请注意，<code>Ext</code> 包含自己的 <code>Ext.Dense</code> 模块，其中进一步包含以下子模块。</p>
<ul>
<li><code>Ext.Dense.Ndarray.S</code></li>
<li><code>Ext.Dense.Ndarray.D</code></li>
<li><code>Ext.Dense.Ndarray.C</code></li>
<li><code>Ext.Dense.Ndarray.Z</code></li>
<li><code>Ext.Dense.Matrix.S</code></li>
<li><code>Ext.Dense.Matrix.D</code></li>
<li><code>Ext.Dense.Matrix.C</code></li>
<li><code>Ext.Dense.Matrix.Z</code></li>
</ul>
<p>这些模块只是 <code>Owl.Dense</code> 模块中原始模块的包装器，因此它们已经提供了大多数已实现的 API。这些包装器模块额外提供的是自动为您打包和解包原始数字类型。但是，您当然可以使用原始数据类型，然后使用 <code>Owl_ext_types</code> 中定义的构造函数自己进行包装。构造函数定义如下。</p>
<div class="highlight">
<pre><code class="language-text">
  type ext_typ =
    F   of float
    C   of Complex.t
    DMS of dms
    DMD of dmd
    DMC of dmc
    DMZ of dmz
    DAS of das
    DAD of dad
    DAC of dac
    DAZ of daz
    SMS of sms
    SMD of smd
    SMC of sms
    SMZ of smd
    SAS of sas
    SAD of sad
    SAC of sac
    SAZ of saz
</code></pre>
</div>
<p>还有相应的 <code>packing</code> 和 <code>unpacking</code> 函数可供使用，请阅读 <code>owl_ext_types.ml &lt;https://github.com/owlbarn/owl/blob/master/src/owl/ext/owl_ext_types.ml&gt;</code>_ 了解更多细节。</p>
<p>让我们通过一些示例了解使用 <code>Ext</code> 模块有多方便。</p>

<div class="highlight">
<pre><code class="language-ocaml">open Owl.Ext;;

let x = Dense.Matrix.S.uniform 5 5;;
let y = Dense.Matrix.C.uniform 5 5;;
let z = Dense.Matrix.D.uniform 5 5;;

x + F 5.;;
x * C Complex.({re = 2.; im = 3.});;
x - y;;
x / y;;
x *@ y;;

(** ... *)

x &gt; z;;
x &gt;. z;;
(x &gt;. z) * x;;
(x &gt;. F 0.5) * x;;
(F 10. * x) + y *@ z;;

(** ... *)

round (F 10. * (x *@ z));;
sin (F 5.) * cos (x + z);;
tanh (x * F 10. - z);;

(** ... *)</code></pre>
</div>

<p>在完成本章之前，我想指出一个注意事项。 <code>Ext</code> 试图通过统一类型来模仿像 Python 这样的动态语言。这阻止了 OCaml 编译器在编译阶段进行类型检查，并在调用函数时引入了额外的开销。因此，除了在顶层进行快速实验之外，我不建议在生产代码中使用 <code>Ext</code> 模块。</p>
</section>
<section class="level2" id="module-structures">
<h2>模块结构</h2>
<p>在 Owl 中，<code>Dense</code> 模块包含密集数据结构的模块。例如，<code>Dense.Matrix</code> 支持密集矩阵的操作。类似地，<code>Sparse</code> 模块包含稀疏数据结构的模块。</p>
<div class="highlight">
<pre><code class="language-text">Dense.Ndarray;;   (* 密集 ndarray *)
Dense.Matrix;;    (* 密集矩阵 *)

Sparse.Ndarray;;  (* 稀疏 ndarray *)
Sparse.Matrix;;   (* 稀疏 ndarray *)</code></pre>
</div>
<p>所有这四个模块都由五个子模块组成，以处理不同类型的数字。</p>
<ul>
<li><code>S</code> 模块支持单精度浮点数 <code>float32</code>；</li>
<li><code>D</code> 模块支持双精度浮点数 <code>float64</code>；</li>
<li><code>C</code> 模块支持单精度复数 <code>complex32</code>；</li>
<li><code>Z</code> 模块支持双精度复数 <code>complex64</code>；</li>
<li><code>Generic</code> 模块通过 GADT 支持所有上述数字类型。</li>
</ul>
<p>使用 <code>Dense.Ndarray</code>，您可以创建一个不超过 16 维的密集 n 维数组。这个限制来源于底层的 <code>Bigarray.Genarray</code> 模块。在实践中，随着维数的增加，空间需求会呈指数级增长，因此这个约束是有意义的。如果您需要的维数超过 16 维，您需要使用 <code>Sparse.Ndarray</code> 创建稀疏数据结构。</p>
</section>
<section class="level2" id="number-and-precision">
<h2>数字和精度</h2>
<p>在确定了合适的数据结构（密集或稀疏）之后，您可以使用模块中的创建函数（例如 <code>empty</code>、<code>create</code>、<code>zeros</code>、<code>ones</code> 等）创建 ndarray/matrix。数字的类型（实数或复数）及其精度（单精度或双精度）需要作为参数传递给创建函数。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Dense.Ndarray.Generic.zeros Float64 [|5;5|];;
&gt;- : (float, float64_elt) Dense.Ndarray.Generic.t =
&gt;
&gt;   C0 C1 C2 C3 C4
&gt;R0  0  0  0  0  0
&gt;R1  0  0  0  0  0
&gt;R2  0  0  0  0  0
&gt;R3  0  0  0  0  0
&gt;R4  0  0  0  0  0
</code></pre>
</div>
<p>使用 <code>zeros</code> 函数，创建的数据结构中的所有元素将被初始化为零。</p>
<p>从技术上讲，<code>S</code>、<code>D</code>、<code>C</code> 和 <code>Z</code> 都是带有显式类型信息的 <code>Generic</code> 模块的包装器。因此，如果直接使用这些子模块，则可以省略传递给 <code>Generic</code> 模块的类型构造函数。</p>
<div class="highlight">
<pre><code class="language-ocaml">Dense.Ndarray.S.zeros [|5;5|];;    (* 单精度实数 ndarray *)
Dense.Ndarray.D.zeros [|5;5|];;    (* 双精度实数 ndarray *)
Dense.Ndarray.C.zeros [|5;5|];;    (* 单精度复数 ndarray *)
Dense.Ndarray.Z.zeros [|5;5|];;    (* 双精度复数 ndarray *)</code></pre>
</div>
<p>以下示例是用于密集矩阵的。</p>
<div class="highlight">
<pre><code class="language-ocaml">Dense.Matrix.S.zeros 5 5;;     (* 单精度实数矩阵 *)
Dense.Matrix.D.zeros 5 5;;     (* 双精度实数矩阵 *)
Dense.Matrix.C.zeros 5 5;;     (* 单精度复数矩阵 *)
Dense.Matrix.Z.zeros 5 5;;     (* 双精度复数矩阵 *)</code></pre>
</div>
<p>以下示例是用于稀疏 ndarray 的。</p>
<div class="highlight">
<pre><code class="language-ocaml">Sparse.Ndarray.S.zeros [|5;5|];;    (* 单精度实数 ndarray *)
Sparse.Ndarray.D.zeros [|5;5|];;    (* 双精度实数 ndarray *)
Sparse.Ndarray.C.zeros [|5;5|];;    (* 单精度复数 ndarray *)
Sparse.Ndarray.Z.zeros [|5;5|];;    (* 双精度复数 ndarray *)</code></pre>
</div>
<p>以下示例是用于稀

疏矩阵的。</p>
<div class="highlight">
<pre><code class="language-ocaml">Sparse.Matrix.S.zeros 5 5;;     (* 单精度实数矩阵 *)
Sparse.Matrix.D.zeros 5 5;;     (* 双精度实数矩阵 *)
Sparse.Matrix.C.zeros 5 5;;     (* 单精度复数矩阵 *)
Sparse.Matrix.Z.zeros 5 5;;     (* 双精度复数矩阵 *)</code></pre>
</div>
<p>简而言之，<code>Generic</code> 模块可以执行子模块可以执行的所有操作，但对于某些函数（例如创建函数），您需要显式传递类型信息。</p>
</section>
<section class="level2" id="polymorphic-functions">
<h2>多态函数</h2>
<p>在 <code>Generic</code> 模块中，通过模式匹配和 GADT 实现了多态性。这意味着 <code>Generic</code> 模块中的许多函数可以处理前述四种不同类型的数字。</p>
<p>在下面的示例中，我以 <code>Dense.Matrix.Generic</code> 模块中的 <code>sum</code> 函数为例。 <code>sum</code> 函数返回矩阵中所有元素的总和。</p>
<div class="highlight">
<pre><code class="language-ocaml">open Owl;;

let x = Dense.Matrix.S.eye 5 in
  Dense.Matrix.Generic.sum x;;

let x = Dense.Matrix.D.eye 5 in
  Dense.Matrix.Generic.sum x;;

let x = Dense.Matrix.C.eye 5 in
  Dense.Matrix.Generic.sum x;;

let x = Dense.Matrix.Z.eye 5 in
  Dense.Matrix.Generic.sum x;;</code></pre>
</div>
<p>正如我们所看到的，无论身份矩阵中包含什么类型的数字，我们总是将其传递给 <code>Dense.Matrix.Generic.sum</code> 函数。类似地，我们可以对其他模块（<code>Dense.Ndarray</code>、<code>Sparse.Matrix</code> 等）和其他函数（<code>add</code>、<code>mul</code>、<code>neg</code> 等）执行相同的操作。</p>
<p>同时，每个子模块还包含相同的一组函数，例如：</p>

<div class="highlight">
<pre><code class="language-ocaml">Dense.Matrix.S.(eye 5 |&gt; sum);;</code></pre>
</div>
</section>
<section class="level2" id="module-shortcuts">
  <h2>模块快捷方式</h2>
  <p>实际上，我们经常使用双精度数值，因此 Owl 提供了一些双精度浮点数数据结构的快捷方式：</p>
  <ul>
  <li><code>Arr</code> 等同于双精度实数 <code>Dense.Ndarray.D</code>；</li>
  <li><code>Mat</code> 等同于双精度实数 <code>Dense.Matrix.D</code>；</li>
  </ul>
  <p>使用这些快捷模块，您不再需要传递类型信息。以下是一些示例。</p>
  <div class="highlight">
  <pre><code class="language-ocaml">Arr.zeros [|5|];;        (* 等同于 Dense.Ndarray.D.zeros [|5|] *)
  Mat.zeros 5 5;;          (* 等同于 Dense.Matrix.D.zeros 5 5 *)</code></pre>
  </div>
  <p>除了创建函数之外，还有更多示例。</p>
  <div class="highlight">
  <pre><code class="language-text">Mat.load "data.mat";;    (* 等同于 Dense.Matrix.D.load "data.mat" *)
  Mat.of_array 5 5 x;;     (* 等同于 Dense.Matrix.D.of_array 5 5 x *)
  Mat.linspace 0. 9. 10;;  (* 等同于 Dense.Matrix.D.linspace 0. 9. 10 *)</code></pre>
  </div>
  <p>如果您实际上更常使用其他数字类型，比如复数，您当然可以根据需要为相应的 <code>S</code>、<code>D</code>、<code>C</code> 和 <code>Z</code> 模块创建自己的别名。</p>
  </section>
  <section class="level2" id="type-casting">
  <h2>类型转换</h2>
  <p>正如我之前提到的，有四种基本数字类型。因此，您可以使用 <code>Generic</code> 模块中的 <code>cast_*</code> 函数将一个值从一种类型转换为另一种类型。</p>
  <ul>
  <li><code>Generic.cast_s2d</code>: 从 <code>float32</code> 转换为 <code>float64</code>；</li>
  <li><code>Generic.cast_d2s</code>: 从 <code>float64</code> 转换为 <code>float32</code>；</li>
  <li><code>Generic.cast_c2z</code>: 从 <code>complex32</code> 转换为 <code>complex64</code>；</li>
  <li><code>Generic.cast_z2c</code>: 从 <code>complex64</code> 转换为 <code>complex32</code>；</li>
  <li><code>Generic.cast_s2c</code>: 从 <code>float32</code> 转换为 <code>complex32</code>；</li>
  <li><code>Generic.cast_d2z</code>: 从 <code>float64</code> 转换为 <code>complex64</code>；</li>
  <li><code>Generic.cast_s2z</code>: 从 <code>float32</code> 转换为 <code>complex64</code>；</li>
  <li><code>Generic.cast_d2c</code>: 从 <code>float64</code> 转换为 <code>complex32</code>；</li>
  </ul>
  <p>实际上，所有这些函数都依赖于以下 <code>cast</code> 函数。</p>
  <div class="highlight">
  <pre><code class="language-text">
    val cast : ('a, 'b) kind -&gt; ('c, 'd) t -&gt; ('a, 'b) t
  </code></pre>
  </div>
  <p>第一个参数指定了转换类型。如果源类型和转换类型相同，则 <code>cast</code> 函数简单地复制传递的值。</p>
  <div class="highlight">
  <pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let x = Arr.uniform [|5;5|]                     (* 在 float64 中创建 *);;
  &gt;val x : Arr.arr =
  &gt;
  &gt;         C0        C1        C2       C3       C4
  &gt;R0 0.648406  0.616945  0.828173 0.579604 0.212017
  &gt;R1 0.960002 0.0563993  0.219521 0.855164 0.414024
  &gt;R2 0.526179  0.532062 0.0640247 0.786426 0.956565
  &gt;R3 0.810557  0.476031  0.516506  0.11439 0.964041
  &gt;R4 0.981665  0.446936  0.276383 0.414747 0.174775
  </code></pre>
  </div>
  <p>现在让我们将 <code>x</code> 从 float64 转换为 complex32。</p>
  <div class="highlight">
  <pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let y = Dense.Ndarray.Generic.cast Complex32 x  (* 转换为 complex32 *);;
  &gt;val y : (Complex.t, complex32_elt) Dense.Ndarray.Generic.t =
  &gt;
  &gt;               C0              C1              C2             C3             C4
  &gt;R0 (0.648406, 0i)  (0.616945, 0i)  (0.828173, 0i) (0.579604, 0i) (0.212017, 0i)
  &gt;R1 (0.960002, 0i) (0.0563993, 0i)  (0.219521, 0i) (0.855164, 0i) (0.414024, 0i)
  &gt;R2 (0.526179, 0i)  (0.532062, 0i) (0.0640247, 0i) (0.786426, 0i) (0.956565, 0i)
  &gt;R3 (0.810557, 0i)  (0.476031, 0i)  (0.516506, 0i)  (0.11439, 0i) (0.964041, 0i)
  &gt;R4 (0.981664, 0i)  (0.446936, 0i)  (0.276383, 0i) (0.414747, 0i) (0.174775, 0i)
  </code></pre>
  </div>
  <p>要了解每个模块中提供的函数的更多信息，请阅读 <code>Generic</code> 模块的相应接口文件。 <code>Generic</code> 模块包含文档。</p>
  <ul>
  <li><a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/dense/owl_dense_ndarray_generic.mli">Dense.Ndarray.Generic</a></li>
  <li><a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/dense/owl_dense_matrix_generic.mli">Dense.Matrix.Generic</a></li>
  <li><a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/sparse/owl_sparse_ndarray_generic.mli">Sparse.Ndarray.Generic</a></li>
  <li><a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/sparse/owl_sparse_matrix_generic.mli">Sparse.Matrix.Generic</a></li>
  </ul>
  </section>
  </section>
  </article></div><a href="visualisation.html" class="next-chapter"><div class="content"><h1><small>Next: Chapter 03</small>Visualisation</h1></div></a><footer><div class="content"><ul><li><a href="http://ocaml.xyz/privacy.html">隐私政策</a></li><li><a href="https://github.com/ryanrhymes">GitHub</a></li></ul><p>版权所有 2017-2023 Liang Wang。</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script></body></html>  
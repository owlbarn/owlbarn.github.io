<html style="" lang="en" class="js flexbox fontface"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><meta content="OCaml Scientific and Engineering Computing - Tutorial Book" name="description"><meta content="OCaml, Data Science, Data Analytics, Analytics, Functional Programming, Machine Learning, Deep Neural Network, Scientific Computing, Numerical Algorithm, Tutorial, Linear Algebra, Matrix" name="keywords"><meta content="Liang Wang" name="author"><title>Mathematical Functions - OCaml Scientific Computing Tutorials</title><link href="css/app.css" rel="stylesheet"><link href="css/prism.css" rel="stylesheet"><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="https://use.typekit.net/gfj8wez.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>try{Typekit.load();}catch(e){}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-123353217-1');</script></head><body><div class="title-bar"><div class="title"><h1>OCaml Scientific Computing Tutorials</h1><h5></h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="https://ocaml.xyz/owl/">API Docs</a><a href="cn/index.html">中文版</a></nav></div></div><div class="wrap"><div class="left-column"><a class="to-chapter" href="toc.html"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body"><section class="level1" id="mathematical-functions">
<h1>数学函数</h1>
<p>从这一章开始，我们将开始探索使用 Owl 进行数字计算的世界。但让我们不要过于仓促。在进入诸如算法微分、优化、计算图等主要内容之前，让我们先尝一些开胃菜。在本章中，我们将介绍 Owl 中如何支持熟悉的数学运算。本章根据不同类型的函数进行组织，您可以随意浏览其中任何部分。请注意，本章中的函数适用于标量值。在后续章节中介绍的 N 维数组模块包含这些在 n 维数组上工作的基本函数，包括向量和矩阵。</p>
<section class="level2" id="basic-functions">
<h2>基本函数</h2>
<section class="level3" id="basic-unary-math-functions">
<h3>基本一元数学函数</h3>
<p>许多基本数学函数将一个浮点数作为输入并返回一个浮点数。我们称它们为<em>一元</em>函数。您可以轻松使用这些一元函数从<code>Maths</code>模块中调用。例如：</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Maths.sqrt 2.
&gt;- : float = 1.41421356237309515
</code></pre>
</div>
<p><span data-cites="tbl:maths:basic_unary" class="citation">[@tbl:maths:basic_unary]</span> 列出了在该模块中支持的这些一元函数。</p>
<table style="width:97%;">
<caption>基本一元数学函数 {#tbl:maths:basic_unary}</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 77%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">解释</th>

</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>abs</code></td>
<td style="text-align: left;"><code>|x|</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>neg</code></td>
<td style="text-align: left;"><code>-x</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>reci</code></td>
<td style="text-align: left;"><code>1/x</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>floor</code></td>
<td style="text-align: left;">the largest integer that is smaller than <code>x</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ceil</code></td>
<td style="text-align: left;">the smallest integer that is larger than <code>x</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>round</code></td>
<td style="text-align: left;">rounds <code>x</code> towards the bigger integer when on the fence</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>trunc</code></td>
<td style="text-align: left;">integer part of <code>x</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>sqr</code></td>
<td style="text-align: left;"><span class="math inline">\(x^2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>sqrt</code></td>
<td style="text-align: left;"><span class="math inline">\(\sqrt{x}\)</span></td>
</tr>
</tbody>
</table>
</section>
<section class="level3" id="basic-binary-functions">
<h3>基本二元数学函数</h3>
<p>与一元函数不同，<em>二元函数</em>接受两个浮点数作为输入，并返回一个浮点数作为输出。大多数常见的算术函数属于这个类别，如<span data-cites="tbl:maths:binary" class="citation">[@tbl:maths:binary]</span>所示。</p>
<table style="width:97%;">
<caption>二元数学函数 {#tbl:maths:binary}</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 77%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>add</code></td>
<td style="text-align: left;"><code>x + y</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>sub</code></td>
<td style="text-align: left;"><code>x - y</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mul</code></td>
<td style="text-align: left;"><code>x * y</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>div</code></td>
<td style="text-align: left;"><code>x / y</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>fmod</code></td>
<td style="text-align: left;"><code>x % y</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>pow</code></td>
<td style="text-align: left;"><span class="math inline">\(x^y\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>hypot</code></td>
<td style="text-align: left;"><span class="math inline">\(\sqrt{x^2 + y^2}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>atan2</code></td>
<td style="text-align: left;">返回<span class="math inline">\(\arctan(y/x)\)</span>，考虑参数的符号；这是向量<span class="math inline">\((x, y)\)</span>相对于 x 轴的角度。</td>
</tr>
</tbody>
</table>
</section>
<section class="level3" id="exponential-and-logarithmic-functions">
<h3>指数和对数函数</h3>
<p>常数<span class="math inline">\(e = \sum_{n=0}^{\infty}\frac{1}{n!}\)</span>是我们称之为<em>自然常数</em>的东西。之所以这样称呼它，是因为指数函数及其逆函数对数在自然界和我们的日常生活中被频繁使用：对数螺线、人口增长、碳测古物、计算银行投资等等。举个例子，在关于细菌的科学实验中，我们可以假设时间<span class="math inline">\(t\)</span>时的细菌数量遵循指数函数<span class="math inline">\(n(t) = Ce^rt\)</span>，其中<span class="math inline">\(C\)</span>是初始人口，<span class="math inline">\(r\)</span>是每日增长率。通过这个模型，我们可以预测在一定时间内细菌的增长情况。</p>
<p>我们还有这个美妙的欧拉公式，它连接了两个最常用的常数和复数和自然数的底：</p>
<p><span class="math display">\[e^{i\pi}+ 1=0.\]</span></p>
<p>指数和对数函数的完整列表，以及一些方便的变体，都在<span data-cites="tbl:maths:explog" class="citation">[@tbl:maths:explog]</span>中呈现。</p>
<table style="width:97%;">
<caption>指数和对数数学函数 {#tbl:maths:explog}</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 77%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>exp</code></td>
<td style="text-align: left;">指数函数<span class="math inline">\(e^x\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>exp2</code></td>
<td style="text-align: left;"><span class="math inline">\(2^x\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>exp10</code></td>
<td style="text-align: left;"><span class="math inline">\(10^x\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>expm1</code></td>
<td style="text-align: left;">返回<span class="math inline">\(\exp(x) - 1\)</span>，但对于<span class="math inline">\(x \sim 0\)</span>更精确</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>log</code></td>
<td style="text-align: left;"><span class="math inline">\(\log_e~x\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>log2</code></td>
<td style="text-align: left;"><span class="math inline">\(\log_2~x\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>log10</code></td>
<td style="text-align: left;"><span class="math inline">\(\log_{10}~x\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>logn</code></td>
<td style="text-align: left;"><span class="math inline">\(\log_n~x\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>log1p</code></td>
<td style="text-align: left;">逆函数<code>expm1</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>logabs</code></td>
<td style="text-align: left;"><span class="math inline">\(\log(|x|)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>xlogy</code></td>
<td style="text-align: left;"><span class="math inline">\(x \log(y)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>xlog1py</code></td>
<td style="text-align: left;"><span class="math inline">\(x \log(y+1)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>logit</code></td>
<td style="text-align: left;"><span class="math inline">\(\log(p/(1-p))\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>expit</code></td>
<td style="text-align: left;"><span class="math inline">\(1/(1+\exp(-x))\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>log1mexp</code></td>
<td style="text-align: left;"><span class="math inline">\(\log(1-\exp(x))\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>log1pexp</code></td>
<td style="text-align: left;"><span class="math inline">\(\log(1+\exp(x))\)</span></td>
</tr>
</tbody>
</table>
</section>

</section>
<section class="level3" id="trigonometric-functions">
<h3>三角函数</h3>
<p>正弦、余弦和正切函数属于<em>三角函数</em>，它们将两条边的比率与直角三角形的角度联系起来。它们包括常用的<code>sin</code>和<code>cos</code>等，以及它们的倒数，如余割、正割等。这些函数在不同领域的数值计算应用中广泛使用，如力学和几何学。这些三角函数都是一元函数，例如：</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Maths.sin (Owl_const.pi /. 2.)
&gt;- : float = 1.
</code></pre>
</div>
<p>它们都包含在 Owl 的数学模块中，如<span data-cites="tbl:maths:triangular" class="citation">[@tbl:maths:triangular]</span>所示。</p>
<table>
<caption>三角数学函数 {#tbl:maths:triangular}</caption>
<colgroup>
<col style="width: 12%">
<col style="width: 15%">
<col style="width: 31%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">解释</th>
<th style="text-align: left;">导数</th>
<th style="text-align: left;">泰勒展开</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>sin</code></td>
<td style="text-align: left;"><span class="math inline">\(\sin(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\cos(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\sum_{n=1}(-1)^{n+1}\frac{x^{2n+1}}{(2n+1)!}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cos</code></td>
<td style="text-align: left;"><span class="math inline">\(\cos(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(-\sin(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\sum_{n=1}(-1)^n\frac{x^{2n}}{(2n)!}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>tan</code></td>
<td style="text-align: left;"><span class="math inline">\(\tan(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(1 + \tan^2(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\sum_{n=1}\frac{4^n(4^n-1)B_n~x^{2n-1}}{(2n)!}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cot</code></td>
<td style="text-align: left;"><span class="math inline">\(1/\tan(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(-(1 + \textrm{cot}^2(x))\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\sum_{n=0}\frac{E_n~x^{2n}}{(2n)!}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>sec</code></td>
<td style="text-align: left;"><span class="math inline">\(1/\cos(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\textrm{sec}(x)\tan(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\sum_{n=0}\frac{2(2^{2n-1})B_n~x^{2n-1}}{(2n)!}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>csc</code></td>
<td style="text-align: left;"><span class="math inline">\(1/\sin(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(-\textrm{csc}(x)\textrm{cot}(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\frac{1}{x}-\sum_{n=1}\frac{4^n~B_n~x^{2n-1}}{(2n)!}\)</span></td>
</tr>
</tbody>
</table>
<p>这里的<span class="math inline">\(B_n\)</span>是第<span class="math inline">\(n\)</span>个<a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E7%BA%B3%E5%88%A9%E6%95%B0">贝努利数</a>，<span class="math inline">\(E_n\)</span>是第<span class="math inline">\(n\)</span>个<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E6%95%B0">欧拉数</a>。图<span data-cites="fig:algodiff:trio" class="citation">[@fig:algodiff:trio]</span>显示了这些三角函数之间的关系。这个图表受到了<a href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E6%9B%B2%E5%87%BD%E6%95%B0">维基百科的一篇文章</a>的启发。这些函数还有相应的反函数：<code>asin</code>、<code>acos</code>、<code>atan</code>、<code>acot</code>、<code>asec</code>、<code>acsc</code>。例如，如果<span class="math inline">\(\sin(a) = b\)</span>，那么<span class="math inline">\(\textrm{asin}(b) = a\)</span>。</p>
<figure>
<img style="width:60.0%" id="fig:algodiff:trio" alt="不同三角函数之间的关系" title="trio" src="images/maths/trio.png"><figcaption>不同三角函数之间的关系</figcaption>
</figure>
<p>另一个相关的概念是<em>双曲函数</em>，如<code>sinh</code>和<code>cosh</code>。这些函数是使用指数函数定义的。正如我们在[@#fig:algodiff:trio]中看到的，三角函数与圆相关。类似地，双曲函数与双曲线相关。例如，点<code>(cosh(x), sinh(x))</code>形成等边双曲线的右半部分，就像圆上的<code>(cos(x), sin(x))</code>一样。双曲函数广泛应用于数值计算中，如微分方程解、双曲几何等。</p>
<ul>

<li><code>sinh</code>: <span class="math inline">\(\frac{e^x - e^{-x}}{2}\)</span>, derivative is <span class="math inline">\(\cosh(x)\)</span>, and taylor expansion is <span class="math inline">\(\sum_{n=0}\frac{x^{2n+1}}{(2n+1)!}\)</span>.</li>
<li><code>cosh</code>: <span class="math inline">\(\frac{e^x + e^{-x}}{2}\)</span>, derivative is <span class="math inline">\(\sinh(x)\)</span>, and taylor expansion is <span class="math inline">\(\sum_{n=0}\frac{x^{2n+1}}{(2n+1)!}\)</span>.</li>
<li><code>tanh</code>: <span class="math inline">\(\frac{\sinh{x}}{\cosh{x}}\)</span>, derivative is <span class="math inline">\(1-\tanh^2(x)\)</span>, and taylor expansion is <span class="math inline">\(\sum_{n=1}\frac{4^n(4^n-1)B_{2n}~x^{2n-1}}{(2n)!}\)</span>.</li>
<li><code>coth</code>: <span class="math inline">\(\frac{\cosh{x}}{\sinh{x}}\)</span>, derivative is <span class="math inline">\(1-\coth^2(x)\)</span>, and taylor expansion is <span class="math inline">\(\frac{1}{x}-\sum_{n=1}\frac{4^n~B_{2n}~x^{2n-1}}{(2n)!}\)</span>.</li>
<li><code>sech</code>: <span class="math inline">\(1/\cosh(x)\)</span>, derivative is <span class="math inline">\(-\tanh(x)/\cosh(x)\)</span>, and taylor expansion is <span class="math inline">\(\sum_{n=0}\frac{E_{2n}~x^{2n}}{(2n)!}\)</span>.</li>
<li><code>csch</code>:<span class="math inline">\(1/\sinh(x)\)</span>, derivative is <span class="math inline">\(-\coth(x)/\sinh(x)\)</span>, and taylor expansion is <span class="math inline">\(\frac{1}{x}+\sum_{n=1}\frac{2(1-2^{2n-1})B_{2n}~x^{2n-1}}{(2n)!}\)</span>.</li>
</ul>
<p>同样地，每个这些函数都有对应的逆函数：<code>asinh</code>、<code>acosh</code>、<code>atanh</code>、<code>acoth</code>、<code>asech</code>、<code>acsch</code>。这些双曲三角函数之间的关系在<span data-cites="fig:algodiff:hyper_trio" class="citation">[@fig:algodiff:hyper_trio]</span>中清晰地描绘出来。</p>
<figure>
<img style="width:70.0%" id="fig:algodiff:hyper_trio" alt="不同双曲三角函数之间的关系" title="hyper_trio" src="images/maths/hyper_trio.png"><figcaption>不同双曲三角函数之间的关系</figcaption>
</figure>
<p>除了这些函数外，还有一些相关的函数。 <code>sinc</code> 返回 <span class="math inline">\(\sin(x)/x\)</span> 并且在 <span class="math inline">\(x=0\)</span> 时为 1。 <code>logsinh</code> 返回 <span class="math inline">\(\log(\sinh(x))\)</span> 但处理大的 <span class="math inline">\(|x|\)</span>。 <code>logcosh</code> 返回 <span class="math inline">\(\log(\cosh(x))\)</span> 但处理大的 <span class="math inline">\(|x|\)</span>。 <code>sindg</code>/<code>cosdg</code>/<code>tandg</code>/<code>cotdg</code> 是以度为单位给定的角度的正弦/余弦/正切/余切。</p>
</section>
<section class="level3" id="other-math-functions">
<h3>其他数学函数</h3>
<p>还有一些在传统数学中可能不太常用的其他函数。像 <code>sigmoid</code> 和 <code>relu</code> 这样的函数在深度学习中经常用作神经网络中的激活函数。激活函数对于神经网络在输出结果、准确性、收敛速度等方面都至关重要。我们将在本书后面的神经网络章节中详细讨论它们。</p>
<ul>
<li><code>sigmoid x</code>: <span class="math inline">\(1 / (1 + \exp(-x))\)</span></li>
<li><code>signum x</code>: 返回 <code>x</code> 的符号：-1、0 或 1</li>
<li><code>softsign x</code>: 平滑 <code>sign</code> 函数</li>
<li><code>relu x</code>: <span class="math inline">\(\max(0, x)\)</span></li>
</ul>
</section>
</section>
<section class="level2" id="special-functions">
<h2>特殊函数</h2>
<p>除了我们刚刚列出的，还有很多特殊函数。你可能以前没听说过它们，但它们在数学分析、物理学等不同领域都有确立的名称，对科学家和工程师很重要。在 Owl 中，这些函数的实现依赖于<a href="http://www.netlib.org/cephes/">Cephes 数学函数库</a>，这是一个包含对科学家和工程师感兴趣的特殊函数的 C 语言库。它们在本节的其余部分中列出。也许我们不能深入挖掘所有这些函数的数学或物理含义，但在需要时您可能会发现它们非常方便。</p>
<section class="level3" id="airy-functions">
<h3>艾里函数</h3>
<p>艾里函数 <code>Ai(x)</code> 以英国天文学家乔治·B·艾里的名字命名。它是二阶线性微分方程的解：</p>
<p><span class="math display">\[y''(x) = xy(x).\]</span></p>
<p>这个微分方程有两个线性无关的解 <code>Ai</code> 和 <code>Bi</code>。Owl 提供 <code>airy</code> 函数来执行此操作：</p>
<div class="highlight">
<pre><code class="language-clike">val airy : float -&gt; float * float * float * float</code></pre>
</div>
<p>返回的四个数字分别是 <code>Ai</code>、它的导数 <code>Ai'</code>、<code>Bi</code> 和它的导数 <code>Bi'</code>。让我们看一个例子。它绘制了两个解 <code>Ai</code> 和 <code>Bi</code> 在<span data-cites="fig:algodiff:airy" class="citation">[@fig:algodiff:airy]</span>中。</p>
<div class="highlight">

<pre><code class="language-ocaml">let x = Mat.linspace (-15.) 5. 200

let y0 = Mat.map (fun x -&gt;
    let ai, _, _, _ = Maths.airy x in ai
) x

let y1 = Mat.map (fun x -&gt;
    let _, _, bi, _ = Maths.airy x in bi
) x

let _ =
  let h = Plot.create "special_airy.png" in
  Plot.(plot ~h ~spec:[ RGB (66, 133, 244); LineStyle 1; LineWidth 2. ] x y0);
  Plot.(plot ~h ~spec:[ RGB (219, 68,  55); LineStyle 2; LineWidth 2. ] x y1);
  Plot.(set_yrange h (-0.5) 1.);
  Plot.(legend_on h ~position:SouthEast [|"Ai"; "Bi"|]);
  Plot.output h</code></pre>
</div>
<figure>
<figure>
<img style="width:60.0%" id="fig:algodiff:airy" alt="艾里方程两个解的示例" title="airy" src="images/maths/example_airy.png">
<figcaption>艾里方程两个解的示例</figcaption>
</figure>
</section>
<section class="level3" id="bessel-functions">
<h3>贝塞尔函数</h3>
<p>贝塞尔函数由数学家丹尼尔·贝努利首次定义，然后由弗里德里希·贝塞尔进行了泛化，它们是贝塞尔微分方程的规范解：</p>
<p><span class="math display">\[x^2y''+xy'+(x^2 - \alpha^2)y = 0.\]</span></p>
<p>复数<span class="math inline">\(\alpha\)</span>被称为贝塞尔函数的“阶”。贝塞尔函数在研究波传播和静电势等许多问题中非常重要，例如在圆柱波导中的电磁波。在解决柱坐标系时，通常使用整数阶或半整数阶的贝塞尔函数。</p>
<p>贝塞尔函数可以分为两种。两种都是贝塞尔微分方程的解，但第一种在原点处是非奇异的，而第二种在原点处是奇异的（<span class="math inline">\(x=0\)</span>）。特殊情况是当<span class="math inline">\(x\)</span>是纯虚数时。在这种情况下，解被称为修改的贝塞尔函数，它也可以被归类为第一种和第二种。基于这些类别，Owl提供了这些函数。</p>
<table style="width:76%;">
<caption>贝塞尔函数 {#tbl:maths:bessel}</caption>
<colgroup>
<col style="width: 12%">
<col style="width: 63%">
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th style="text-align: left;">解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>j0 x</code></td>
<td style="text-align: left;">零阶第一类贝塞尔函数</td>
</tr>
<tr class="even">
<td><code>j1 x</code></td>
<td style="text-align: left;">一阶第一类贝塞尔函数</td>
</tr>
<tr class="odd">
<td><code>jv x y</code></td>
<td style="text-align: left;">实阶第一类贝塞尔函数</td>
</tr>
<tr class="even">
<td><code>y0 x</code></td>
<td style="text-align: left;">零阶第二类贝塞尔函数</td>
</tr>
<tr class="odd">
<td><code>y1 x</code></td>
<td style="text-align: left;">一阶第二类贝塞尔函数</td>
</tr>
<tr class="even">
<td><code>yv x y</code></td>
<td style="text-align: left;">实阶第二类贝塞尔函数</td>
</tr>
<tr class="odd">
<td><code>yn a x</code></td>
<td style="text-align: left;">整数阶第二类贝塞尔函数</td>
</tr>
<tr class="even">
<td><code>i0 x</code></td>
<td style="text-align: left;">零阶修改贝塞尔函数</td>
</tr>
<tr class="odd">
<td><code>i1 x</code></td>
<td style="text-align: left;">一阶修改贝塞尔函数</td>
</tr>
<tr class="even">
<td><code>iv x y</code></td>
<td style="text-align: left;">实阶修改贝塞尔函数</td>
</tr>
<tr class="odd">
<td><code>i0e x</code></td>
<td style="text-align: left;">零阶指数缩放修改贝塞尔函数</td>
</tr>
<tr class="even">
<td><code>i1e x</code></td>
<td style="text-align: left;">一阶指数缩放修改贝塞尔函数</td>
</tr>
<tr class="odd">
<td><code>k0 x</code></td>
<td style="text-align: left;">零阶第二类修改贝塞尔函数</td>
</tr>
<tr class="even">
<td><code>k1</code></td>
<td style="text-align: left;">一阶第二类修改贝塞尔函数</td>
</tr>
<tr class="odd">
<td><code>k0e</code></td>
<td style="text-align: left;">零阶指数缩放第二类修改贝塞尔函数</td>
</tr>
<tr class="even">
<td><code>k1e</code></td>
<td style="text-align: left;">一阶指数缩放第二类修改贝塞尔函数</td>
</tr>
</tbody>
</table>
</section>

<section class="level3" id="elliptic-functions">
<h3>椭圆函数</h3>
<p><em>Jacobi椭圆函数</em>用于研究摆动运动。共有十二个Jacobi椭圆函数，而我们在这里包括的<code>ellipj</code>返回其中三个：<code>sn</code>、<code>cn</code>和<code>dn</code>。该函数的第四个输出<code>phi</code>被称为输入<code>u</code>的振幅。</p>
<p>另一方面，<em>椭圆积分</em>最初用于找到椭圆的周长。椭圆积分函数可以表示为：<span class="math display">\[f(x)=\int_c^xR(t, \sqrt{P(t)})dt,\]</span>其中<span class="math inline">\(R\)</span>是其两个参数的有理函数，<span class="math inline">\(P\)</span>是次数为3或4的多项式，没有重复的根，<span class="math inline">\(c\)</span>是一个常数。椭圆积分可以分为“完全”或“不完全”。前者是一个单一参数的函数，而后者包含两个参数。每个椭圆积分都可以变换，使其包含有理函数和三个Legendre标准形式的积分，根据这些形式，椭圆可以分为第一、第二和第三类。Owl中的椭圆函数列在<span data-cites="tbl:maths:elliptic" class="citation">[@tbl:maths:elliptic]</span>中。</p>
<table>
<caption>椭圆函数 {#tbl:maths:elliptic}</caption>
<colgroup>
<col style="width: 21%">
<col style="width: 78%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ellipj u m</code></td>
<td style="text-align: left;">参数<code>m</code>在0和1之间，实参数<code>u</code>的Jacobi椭圆函数</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ellipk m</code></td>
<td style="text-align: left;">完全椭圆积分的第一类</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ellipkm1 p</code></td>
<td style="text-align: left;">围绕m = 1的完全椭圆积分的第一类</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ellipkinc phi m</code></td>
<td style="text-align: left;">第一类不完全椭圆积分</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ellipe m</code></td>
<td style="text-align: left;">完全椭圆积分的第二类</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ellipeinc phi m</code></td>
<td style="text-align: left;">第二类不完全椭圆积分</td>
</tr>
</tbody>
</table>
<p>我们可以使用<code>ellipe</code>计算椭圆的周长。通常，要计算这个需要微积分，但椭圆函数提供了一个简单的解决方案。假设一个椭圆的半长轴<span class="math inline">\(a=4\)</span>，半短轴<span class="math inline">\(b=3\)</span>。我们可以简单地使用<span class="math inline">\(4a\textrm{ellipe}(1 - \frac{b^2}{a^2})\)</span>来计算其周长。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let a = 4.
&gt;val a : float = 4.
let b = 3.
&gt;val b : float = 3.
let c = 4. *. a *. Maths.(ellipe (1. -. pow (b /. a) 2.))
&gt;val c : float = 22.1034921607095072
</code></pre>
</div>
</section>
<section class="level3" id="gamma-functions">
<h3>伽玛函数</h3>
<p>对于正整数n，<em>伽玛函数</em>是阶乘函数：</p>
<p><span class="math display">\[\Gamma(n) = (n-1)!\]</span></p>
<p>对于具有正实部的复数<span class="math inline">\(z\)</span>，伽玛函数定义为：</p>
<p><span class="math display">\[\Gamma(z) = \int_0^{\infty}x^{z-1}e^{-x}dx.\]</span></p>
<p>这里的伽玛函数是从零到无穷的积分。如果我们将其更改为从零到某个上限的积分，则称为“下不完全伽玛函数”。同样，如果是从某个下限到无穷的积分，则该积分称为“上不完全伽玛函数”。</p>
<p>伽玛函数在流体动力学、几何学、天体物理学等多个领域广泛应用。它特别适用于描述时间或空间中呈指数衰减的过程的普遍模式。Owl提供的伽玛函数及相关函数列在<span data-cites="tbl:maths:gamma" class="citation">[@tbl:maths:gamma]</span>中。</p>
<table>
<caption>伽玛函数

<colgroup>
<col style="width: 32%">
<col style="width: 67%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>gamma z</code></td>
<td style="text-align: left;">返回 Gamma 函数的值</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>rgamma z</code></td>
<td style="text-align: left;">Gamma 函数的倒数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>loggamma z</code></td>
<td style="text-align: left;">Gamma 函数对数的主支</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>gammainc a x</code></td>
<td style="text-align: left;">正则化的下不完全 Gamma 函数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>gammaincinv a y</code></td>
<td style="text-align: left;"><code>gammainc</code> 的反函数</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>gammaincc a x</code></td>
<td style="text-align: left;">补充不完全 Gamma 积分</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>gammainccinv a y</code></td>
<td style="text-align: left;"><code>gammaincc</code> 的反函数</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>psi z</code></td>
<td style="text-align: left;">digamma 函数</td>
</tr>
</tbody>
</table>
<p>这里是使用 <code>gamma</code> 的一个例子。</p>
<div class="highlight">
<pre><code class="language-ocaml">let x = Mat.linspace (-3.5) 5. 2000

let y = Mat.map Maths.gamma x

let _ =
  let h = Plot.create "example_gamma.png" in
  Plot.(plot ~h ~spec:[ RGB (66, 133, 244); LineStyle 1; LineWidth 2. ] x y);
  Plot.(set_yrange h (-10.) 20.);
  Plot.output h</code></pre>
</div>
<figure>
<img style="width:60.0%" id="fig:algodiff:gamma" alt="Examples of Gamma function along part of the real axis" title="gamma" src="images/maths/example_gamma.png"><figcaption>实轴部分的 Gamma 函数示例</figcaption>
</figure>
</section>
<section class="level3" id="beta-functions">
<h3>Beta 函数</h3>
<p>Beta 函数定义为：</p>
<p><span class="math display">\[B(x,y) = \int_0^1t^{x-1}(1-t)^{y-1}dt = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}\]</span></p>
<p>这里 <span class="math inline">\(\Gamma\)</span> 是 Gamma 函数，类似于 Gamma 函数，Beta 函数也有其“不完全”版本。不完全 Beta 函数将此定义扩展为：</p>
<p><span class="math display">\[B(x, a, b) = \int_0^xt^{a-1}(1-t)^{b-1}dt.\]</span></p>
<p>在 Owl 中，可以使用 <code>Maths</code> 模块中的 <code>beta x y</code> 函数调用 Beta 函数，其不完全版本是 <code>betainc a b x</code>。我们还提供了 <code>betaincinv</code> 函数，它是 <code>betainc</code> 的反函数。</p>
<p>Beta 函数有几个属性。例如，下面的代码显示了 beta 函数和 gamma 函数之间的关系。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let x = Maths.beta 3. 4.
&gt;val x : float = 0.0166666666666666664
let y = Maths.((gamma 3.) *. (gamma 4.) /. (gamma (7.)))
&gt;val y : float = 0.0166666666666666664
</code></pre>
</div>
<p>另一个属性是其对称性，即 <span class="math inline">\(B(x,y) = B(y, x)\)</span>。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let x = Maths.beta 3. 4.
&gt;val x : float = 0.0166666666666666664
let y = Maths.beta 4. 3.
&gt;val y : float = 0.0166666666666666664
</code></pre>
</div>

<section class="level3" id="struve-functions">
<h3>斯特鲁夫函数</h3>
<p><em>斯特鲁夫函数</em>定义如下：<span class="math display">\[H_v(x) = (z/2)^{v + 1} \sum_{n=0}^\infty \frac{(-1)^n (z/2)^{2n}}{\Gamma(n + \frac{3}{2}) \Gamma(n + v + \frac{3}{2})},\]</span></p>
<p>其中<span class="math inline">\(\Gamma\)</span>是伽玛函数。除非<span class="math inline">\(v\)</span>是整数，否则<span class="math inline">\(x\)</span>必须为正数。斯特鲁夫函数广泛应用于各种物理应用，如水波问题和非定常空气动力学计算等。</p>
<p>Owl函数<code>struve v x</code>返回斯特鲁夫函数的值。参数<span class="math inline">\(v\)</span>被称为此函数的<em>阶</em>。以下是显示阶从0到4的斯特鲁夫函数曲线的示例。</p>
<div class="highlight">
<pre><code class="language-ocaml">let _ =
  let h = Plot.create "example_struve.png" in
  Plot.(plot_fun ~h ~spec:[ RGB (66, 133, 244); LineStyle 1; LineWidth 2.] (Maths.struve 0.) (-12.) 12.);
  Plot.(plot_fun ~h ~spec:[ RGB (219, 68,  55); LineStyle 2; LineWidth 2.] (Maths.struve 1.) (-12.) 12.);
  Plot.(plot_fun ~h ~spec:[ RGB (244, 180,  0); LineStyle 3; LineWidth 2.] (Maths.struve 2.) (-12.) 12.);
  Plot.(plot_fun ~h ~spec:[ RGB (77,  81,  57); LineStyle 1; LineWidth 2.] (Maths.struve 3.) (-12.) 12.);
  Plot.(plot_fun ~h ~spec:[ RGB (111, 51, 129); LineStyle 2; LineWidth 2.] (Maths.struve 4.) (-12.) 12.);
  Plot.(set_yrange h (-3.) 5.);
  Plot.(legend_on h ~position:SouthEast [|"H0"; "H1"; "H2"; "H3"; "H4"|]);
  Plot.output h</code></pre>
</div>
<figure>
<img style="width:60.0%" id="fig:algodiff:struve" alt="不同阶数的斯特鲁夫函数示例。" title="struve" src="images/maths/example_struve.png"><figcaption>不同阶数的斯特鲁夫函数示例。</figcaption>
</figure>
</section>
<section class="level3" id="zeta-functions">
<h3>ζ函数</h3>
<p><em>赫维茨 zeta 函数</em> <code>zeta x q</code>定义如下：</p>
<p><span class="math display">\[\zeta(x, q) = \sum_{k=0}^{\infty}\frac{1}{(k+q)^x}.\]</span></p>
<p>当<span class="math inline">\(q\)</span>设置为1时，该函数缩减为<em>黎曼 zeta 函数</em>。函数<code>zetac x</code>返回黎曼 zeta 函数减1。ζ函数经常用于分析动态系统。此外，黎曼 zeta 函数在数论中发挥重要作用，并在量子物理、概率论和应用统计学等广泛应用。</p>
<p>我们可以在特定点评估ζ函数，例如：</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Maths.zeta 4. 1.
&gt;- : float = 1.08232323371113837
(Maths.pow Owl_const.pi 4.) /. 90.
&gt;- : float = 1.08232323371113792
</code></pre>
</div>
</section>
<section class="level3" id="error-functions">
<h3>误差函数</h3>
<p>这里的误差函数不是关于编程中的错误处理，而是另一类特殊函数。在数学中，误差函数定义为：<span class="math display">\[\frac{2}{\sqrt{\pi}}\int_0^x e^{-t^2})dt.\]</span></p>
<p>误差函数经常出现在概率和统计学中。实际上，在统计学中，对于非负值<code>x</code>，<code>erf x</code>是随机变量<code>y</code>落在范围<code>[-x, x]</code>的概率。这里<code>y</code>服从均值为0、方差为0.5的正态分布。由于它表示某种概率，<em>补充</em>误差函数<code>1 - erf(x)</code>也经常使用。Owl中的误差函数及其相关变体列在<span data-cites="tbl:maths:error" class="citation">[@tbl:maths:error]</span>中。</p>
<table>
<caption>误差函数 {#tbl:maths:error}</caption>
<colgroup>
<col style="width: 32%">
<col style="width: 67%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>erf x</code></td>
<td style="text-align: left;">误差函数</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>erfc x</code></td>
<td style="text-align: left;">补充误差函数：<span class="math inline">\(1 - \textrm{erf}(x)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>erfcx x</code></td>
<td style="text-align: left;">缩放的补充误差函数：<span class="math inline">\(\exp(x^2) \mathrm{erfc}(x)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>erfinv x</code></td>
<td style="text-align: left;">误差函数的反函数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>erfcinv x</code></td>
<td style="text-align: left;">补充误差函数的反函数</td>
</tr>
</tbody>
</table>
<p>误差函数是一个sigmoid函数。我们可以通过下面的代码观察其形状。</p>
<div class="highlight">
<pre><code class="language-ocaml">let _ =
  let h = Plot.create "example_erf.png" in
  Plot.(plot_fun ~h ~spec:[ RGB (66, 133, 244); LineStyle 1; LineWidth 2.] Maths.erf (-3.) 3.);
  Plot.output h</code></pre>
</div>
<figure>
<img style="width:75.0%" id="fig:algodiff:erf" alt="误差函数的绘图。" title="struve" src="images/maths/example_erf.png"><figcaption>误差函数的绘图。</figcaption>
</figure>
</section>
<section class="level3" id="integral-functions">
<h3>积分函数</h3>
<p>除了我们到目前为止提到的内容，Owl还提供了几个特殊积分函数。</p>
<p>例如，<em>道森函数</em>定义为：<span class="math display">\[D(x) = e^{-x^2}\int_0^x~e^{t^2}dt\]</span></p>
<p>而<em>菲涅尔三角函数积分</em>返回一个包含两部分的元组：<span class="math display">\[S(x) = \int_0^x~sin(t^2)dt, C(x) = \int_0^x~cos(t^2)dt.\]</span></p>
<p>与许多其他特殊函数一样，这两种类型的积分受到了物理研究的启发，如电磁问题。它们分别由<code>dawsn</code>和<code>fresnel</code>函数在<code>Maths</code>模块中提供。我们可以通过绘图观察这些积分函数的函数。</p>
<div class="highlight">
<pre><code class="language-ocaml">let _ =
  let h = Plot.create ~m:1 ~n:2 "example_integrals.png" in
  Plot.subplot h 0 0;
  Plot.(plot_fun ~h ~spec:[ RGB (66, 133, 244); LineStyle 1; LineWidth 2.] Maths.dawsn (-5.) 5.);
  Plot.set_ylabel h "dawsn(x)";
  Plot.subplot h 0 1;
  Plot.(plot_fun ~h ~spec:[ RGB (66, 133, 244); LineStyle 1; LineWidth 2.] (fun x -&gt; let s, _ = Maths.fresnel x in s) 0. 5.);
  Plot.(plot_fun ~h ~spec:[ RGB (219, 68,  55); LineStyle 2; LineWidth 2.] (fun x -&gt; let _, c = Maths.fresnel x in c) 0. 5.);
  Plot.(legend_on h ~position:SouthEast [|"S(x)"; "C(x)"|]);
  Plot.set_ylabel h "fresnel(x)";
  Plot.output h</code></pre>
</div>
</section>

<figure>
<img style="width:100.0%" id="fig:algodiff:integrals" alt="Dawson 和 Fresnel 积分函数的图表" title="积分" src="images/maths/example_integrals.png"><figcaption>Dawson 和 Fresnel 积分函数的图表。</figcaption>
</figure>
<p>除了这两个之外，还提供了其他几种特殊积分函数。完整列表显示在<span data-cites="tbl:maths:integral" class="citation">[@tbl:maths:integral]</span>中。</p>
<table>
<caption>特殊积分函数 {#tbl:maths:integral}</caption>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>expn n x</code></td>
<td style="text-align: left;">广义指数积分 <span class="math inline">\(E_n(x) = x^{n-1}\int_x^{\infty}\frac{e^{-t}}{t^n}dt\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>shi x</code></td>
<td style="text-align: left;">双曲正弦积分：<span class="math inline">\(\int_0^x~\frac{\sinh~t}{t}dt\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>chi x</code></td>
<td style="text-align: left;">双曲余弦积分：<span class="math inline">\(\gamma + \log(x) + \int_0^x~\frac{\cosh~t -1}{t}dt\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>shichi x</code></td>
<td style="text-align: left;">(<code>shi x</code>, <code>chi x</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>si x</code></td>
<td style="text-align: left;">正弦积分：<span class="math inline">\(\int_0^x~\frac{\sin~t}{t}dt\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ci x</code></td>
<td style="text-align: left;">余弦积分：<span class="math inline">\(\gamma + \log(x) + \int_0^x~\frac{\cos~t -1}{t}dt\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>sici x</code></td>
<td style="text-align: left;">(<code>si x</code>, <code>ci x</code>)</td>
</tr>
</tbody>
</table>
</section>
</section>
<section class="level2" id="factorials">
<h2>阶乘</h2>
<p>在函数之后，让我们转向一个我们熟悉的概念：阶乘。阶乘的定义很简单：</p>
<p><span class="math inline">\(F(n) = n! = n \times (n - 1) \times (n-2) \ldots \times 1\)</span></p>
<p>阶乘函数及其几个变体都包含在<code>Math</code>模块中。</p>
<table>
<caption>阶乘函数 {#tbl:maths:factorial}</caption>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>fact n</code></td>
<td style="text-align: left;">阶乘函数<span class="math inline">\(!n\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>log_fact n</code></td>
<td style="text-align: left;">阶乘函数的对数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>doublefact n</code></td>
<td style="text-align: left;">双阶乘函数计算<span class="math inline">\(n!! = n(n-2)(n-4)\dots 2\)</span>（或 1）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>log_doublefact n</code></td>
<td style="text-align: left;">双阶乘函数的对数</td>
</tr>
</tbody>
</table>
</section>

<p>阶乘函数接受整数作为输入，例如：</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Maths.fact 5
&gt;- : float = 120.
</code></pre>
</div>
<p>阶乘在数学的许多领域中都有应用，尤其是在组合学中。排列和组合都以阶乘的形式定义。排列函数返回有序子集的数量<span class="math inline">\(n!/(n-k)!\)</span>，长度为<span class="math inline">\(k\)</span>，从包含<span class="math inline">\(n\)</span>个元素的集合中取出。组合函数返回集合<span class="math inline">\(n\)</span>个元素中<span class="math inline">\(k\)</span>个元素的子集数量，即<span class="math inline">\({n\choose k} = n!/(k!(n-k)!)\)</span>。表<span data-cites="tbl:maths:perm" class="citation">[@tbl:maths:perm]</span>提供了您可以在<code>Math</code>模块中使用的组合数学函数。</p>
<table>
<caption>排列和组合函数 {#tbl:maths:perm}</caption>
<colgroup>
<col style="width: 28%">
<col style="width: 71%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>permutation n k</code></td>
<td style="text-align: left;">排列数</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>permutation_float n k</code></td>
<td style="text-align: left;">类似于<code>permutation</code>，但处理更大范围并返回浮点数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>combination n k</code></td>
<td style="text-align: left;">组合数</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>combination_float n k</code></td>
<td style="text-align: left;">类似于<code>combination</code>，但处理更大范围并返回浮点数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>log_combination n k</code></td>
<td style="text-align: left;">返回<span class="math inline">\({n\choose k}\)</span>的对数</td>
</tr>
</tbody>
</table>
<p>让我们看一个简单的例子。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let x = Maths.combination 10 2
&gt;val x : int = 45
let y = Maths.combination_float 10 2
&gt;val y : float = 45.
</code></pre>
</div>
</section>
<section class="level2" id="interpolation-and-extrapolation">
<h2>插值和外推</h2>
<p>有时我们不知道函数<span class="math inline">\(f\)</span>的完整描述，只知道其中一些点，因此无法计算其在任意点的值。我们的目标是通过在给定数据点之间绘制平滑曲线来估计<span class="math inline">\(f(x)\)</span>。如果<span class="math inline">\(x\)</span>在给定数据的范围内，这个任务称为<em>插值</em>，否则称为<em>外推</em>，后者要困难得多。</p>
<p><code>Owl_maths_interpolate</code>模块提供了一个用于插值和外推的<code>polint</code>函数：</p>
<div class="highlight">
<pre><code class="language-clike">val polint : float array -&gt; float array -&gt; float -&gt; float * float</code></pre>
</div>
<p>函数<code>polint xs ys x</code>对给定的数组<code>xs</code>和<code>ys</code>执行多项式插值。给定数组<span class="math inline">\(xs[0 \ldots (n-1)]\)</span>和<span class="math inline">\(ys[0\ldots~(n-1)]\)</span>，以及一个值<code>x</code>，此函数返回一个值<code>y</code>和一个误差估计<code>dy</code>。</p>
<p>顾名思义，<code>polint</code>使用可能通过给定点的最低可能次数的多项式来近似复杂的曲线。我们通过一个例子展示这种插值方法的工作原理。在前一节中，我们已经说过Gamma函数实际上是整数函数<span class="math inline">\(y(x) = (n-1)!\)</span>的插值解。因此，我们可以指定平面上由该阶乘函数生成的五个节点，并查看插值函数与Gamma函数本身相比的效果。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let x = [|2; 3; 4; 5; 6|]
&gt;val x : int array = [|2; 3; 4; 5; 6|]
let y = Array.map (fun x -&gt; Maths.fact (x - 1)) x
&gt;val y : float array = [|1.; 2.; 6.; 24.; 120.|]
let x = Array.map float_of_int x
&gt;val x : float array = [|2.; 3.; 4.; 5.; 6.|]
</code></pre>
</div>
</section>
<section class="level2" id="integration">
<h2>积分</h2>
<p>我们已经介绍了一些特殊的积分函数，但我们仍然需要适用于任何输入函数的一般积分方法。给定一个函数<span class="math inline">\(f\)</span>，它接受一个实变量和实轴上的一个区间<span class="math inline">\([a, b]\)</span>，该函数的积分</p>
<p><span class="math display">\[\int_a^bf(x)dx\]</span></p>
<p>可以被视为笛卡尔平面上由曲线<span class="math inline">\(f\)</span>界定、在<span class="math inline">\([a, b]\)</span>范围内的区域的带符号面积之和。位于x轴上方的区域增加到总和中，而位于x轴下方的区域则从总面积中减去。</p>
<p>在<code>Owl_maths_quandrature</code>模块中，Owl提供了几种数值例程，以帮助您进行积分。例如，我们可以使用以下代码计算<span class="math inline">\(\int_1^4x^2\)</span>：</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Owl_maths_quadrature.trapz (fun x -&gt; x ** 2.) 1. 4.
&gt;- : float = 21.0001344681758439
</code></pre>
</div>
<p>我们可以使用微积分基本定理验证这个结果：</p>
<p><span class="math display">\[\int_1^4x^2 = (4^3 -1^3) / 3 = 21\]</span>。</p>
<p>所以您可能会想，这个<code>trapz</code>是什么？为什么结果不是确切的<code>21</code>？使用数值方法（或<em>数值积分</em>）进行积分可以追溯到微积分的发明甚至更早。基本思想是使用小面积的总和来近似积分的面积。存在许多算法用于数值积分，使用梯形规则是其中之一。</p>
<p>这个经典方法将<code>a</code>到<code>b</code>划分为<span class="math inline">\(N\)</span>个等间距的横坐标：<span class="math inline">\(x_0, x_1, \ldots, x_N\)</span>。在<span class="math inline">\(x_i\)</span>和<span class="math inline">\(x_j\)</span>之间的每个区域被看作一个“梯形”，并且面积公式计算为：</p>
<p><span class="math display">\[\int_{x_0}^{x_1}f(x)dx = h(\frac{f(x_0)}{2} + \frac{f(x_1)}{2}) + O(h^3f'').\]</span></p>
<p>这里的误差项<span class="math inline">\(O(h^3f'')\)</span>表明近似误差与横坐标大小<span class="math inline">\(h\)</span>和原始函数的二阶导数有关。函数<code>trapz</code>实现了这种方法。它的接口是：</p>
<div class="highlight">
<pre><code class="language-clike">val trapz : ?n:int -&gt; ?eps:float -&gt; (float -&gt; float) -&gt; float -&gt; float -&gt; float</code></pre>
</div>
<p><code>trapz ~n ~eps f a b</code>使用梯形法计算<code>f</code>在区间<code>[a,b]</code>上的积分。它通过迭代多个阶段工作，每个阶段通过添加更多的内部点来提高准确性。参数<span class="math inline">\(n\)</span>指定最大步数，默认为20，<code>eps</code>是所需的分数精度阈值，默认为<code>1e-6</code>。</p>
<p>其他方法在接口上类似于<code>trapz</code>，只是在实现上有所不同。例如，<code>simpson</code>使用辛普森公式：</p>
<p><span class="math display">\[\int_{x_0}^{x_2}f(x)dx = h(\frac{f(x_0)}{3} + \frac{4f(x_1)}{3} + \frac{f(x_2)}{3}) + O(h^5f(4)).\]</span></p>
<p>然后有<em>龙贝格积分</em>（<code>romberg</code>）可以选择不同阶数的方法以提供良好的准确性，这些算法通常比<code>trapz</code>和<code>simpson</code>方法快得多。此外，如果横坐标可以变化，我们有自适应的固定容差高斯积分（<code>gaussian</code>）和固定阶数的高斯积分（<code>gaussian_fixed</code>）。</p>
<p>例如，我们可以使用数值积分方法计算上一节中的特殊正弦积分函数<span class="math inline">\(Si(x)=\int_0^x\frac{sin(t)}{t}dt\)</span>。让我们设定<span class="math inline">\(x=4\)</span>。我们可以看到数值方法<code>gaussian</code>很好地逼近了这个特殊积分函数。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">

</div>
</section>
<section class="level2" id="utility-functions">
<h2>实用函数</h2>
<p>除了我们到目前为止提到的内容之外，还有一些值得一提的实用数学函数。</p>
<p>我们知道，质数是大于<code>1</code>的自然数，不能通过两个较小的自然数相乘而得到。这是信息技术中的一个关键概念，广泛应用于公钥密码学等应用。函数<code>is_prime</code>检查整数是否为质数。该函数对所有能由整数表示的数字都是确定性的。它是使用<a href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test">Miller-Rabin素性测试</a>方法实现的。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Maths.is_prime 997
&gt;- : bool = true
</code></pre>
</div>
<p>另一个与数论相关的概念是<em>费马因子分解</em>，它将奇整数表示为两个平方的差：<span class="math inline">\(N = a^2 - b^2\)</span>，因此<code>N</code>可以分解为<span class="math inline">\((a+b)(a-b)\)</span>。函数<code>fermat_fact</code>对奇数<code>N</code>执行费马因子分解，即分解为两个大致相等的因子<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>，使得<span class="math inline">\(N=x\times~y\)</span>。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Maths.fermat_fact 6557
&gt;- : int * int = (83, 79)
83 * 79
&gt;- : int = 6557
</code></pre>
</div>
<p>接下来的两个函数涉及计算机中浮点数的精度。</p>
<p><code>nextafter from to</code>返回<code>from</code>在<code>to</code>方向上的下一个可表示的双精度值。另一个函数<code>nextafter from to</code>返回<code>from</code>在<code>to</code>方向上的下一个可表示的单精度值。在两种情况下，如果<code>from</code>等于<code>to</code>，则返回此值本身。例如：</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Maths.nextafterf 1. 2.;;
&gt;- : float = 1.00000011920928955
Maths.nextafter 1. 2.;;
&gt;- : float = 1.00000000000000022
Maths.nextafter 1. 0.;;
&gt;- : float = 0.999999999999999889
</code></pre>
</div>
</section>
<section class="level2" id="summary">
<h2>总结</h2>
<p>我们从我们熟悉的数学函数开始讨论数值计算的主题。本章介绍了 Owl 支持的数学函数，包括基本和常用函数、一些不太常用但仍然重要的特殊函数、阶乘、插值、外推、积分等。随时跳转到您感兴趣的任何部分，并使用这些函数解决手头的数学问题。您可能会发现 Owl 与任何其他数值库一样优秀的计算器。</p>
</section>
</section>
</article></div><a href="stats.html" class="next-chapter"><div class="content"><h1><small>下一步：第05章</small>统计函数</h1></div></a><footer><div class="content"><ul><li><a href="http://ocaml.xyz/privacy.html">隐私政策</a></li><li><a href="https://github.com/ryanrhymes">GitHub</a></li></ul><p>版权所有 2017-2023 梁旺。</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script></body></html>
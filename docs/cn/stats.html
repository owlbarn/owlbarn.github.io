<html style="" lang="en" class="js flexbox fontface"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><meta content="OCaml Scientific and Engineering Computing - Tutorial Book" name="description"><meta content="OCaml, Data Science, Data Analytics, Analytics, Functional Programming, Machine Learning, Deep Neural Network, Scientific Computing, Numerical Algorithm, Tutorial, Linear Algebra, Matrix" name="keywords"><meta content="Liang Wang" name="author"><title>Statistical Functions - OCaml Scientific Computing Tutorials</title><link href="css/app.css" rel="stylesheet"><link href="css/prism.css" rel="stylesheet"><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="https://use.typekit.net/gfj8wez.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>try{Typekit.load();}catch(e){}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-123353217-1');</script></head><body><div class="title-bar"><div class="title"><h1>OCaml Scientific Computing Tutorials</h1><h5></h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="https://ocaml.xyz/owl/">API Docs</a><a href="../index.html">English Version</a></nav></div></div><div class="wrap"><div class="left-column"><a class="to-chapter" href="toc.html"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body"><section class="level1" id="statistical-functions">
<h1>统计函数</h1>
<p>统计学是数据分析中不可或缺的工具，它帮助我们从数据中获取洞察。Owl中的统计函数可以分为三组：描述性统计、分布和假设检验。</p>
<section class="level2" id="random-variables">
<h2>随机变量</h2>
<p>我们从为<em>事件</em>分配概率开始。一个事件可能包括有限或无限数量的可能结果。所有可能的输出组成<em>样本空间</em>。为了更好地捕捉这些分配过程，我们需要<em>随机变量</em>的概念。</p>
<p>随机变量是将事件的样本输出与一些感兴趣的数字关联的函数。想象一下经典的抛硬币游戏，我们抛硬币四次，结果是“正面”，“正面”，“反面”，“正面”。我们对这个结果中“正面”的数量感兴趣。因此，我们创建一个随机变量“X”来表示这个数字，并且 <code>X(["正面", "正面", "反面", "正面"]) = 3</code>。您可以看到使用随机变量可以大大减少事件样本空间。</p>
<p>根据它可以取的值的数量，随机变量可以大致分为<em>离散</em>随机变量（有限数量的可能输出）和<em>连续</em>随机变量（无限数量的可能输出）。</p>
<section class="level3" id="discrete-random-variables">
<h3>离散随机变量</h3>
<p>回到抛硬币的例子。假设硬币是特殊铸造的，以便抛出正面的概率为<span class="math inline">\(p\)</span>。在这种情况下，我们抛三次。使用正面数量作为随机变量<span class="math inline">\(X\)</span>，它包含四个可能的结果：0、1、2或3。</p>
<p>我们可以计算每个输出结果的可能性。由于每次投掷都是一个独立的试验，三个正面的可能性 <code>P(X=2)</code> 是 <span class="math inline">\(p^3\)</span>。两个正面包括三种情况：HHT、HTH、THH，每种情况的概率为 <span class="math inline">\(p^2(1-p)\)</span>，总共 <span class="math inline">\(P(X=2) = 3p^2(1-p)\)</span>。类似地，<span class="math inline">\(P(X=1)=3p(1-p)^2\)</span>，<span class="math inline">\(P(X=0)=(1-p)^3\)</span>。</p>
<p>形式上，考虑一系列<span class="math inline">\(n\)</span>个独立的试验，每个试验包含两个可能的结果，并且感兴趣的结果发生的概率为<span class="math inline">\(p\)</span>，则随机变量<span class="math inline">\(X\)</span>的概率分布是（<span class="math inline">\(X\)</span>是感兴趣结果的数量）：</p>
<p><span class="math display">\[P(X=k) = {N\choose k} p^k(1-p)^{n-k}.\]</span> {#eq:stats:binomial_pdf}</p>
<p>这种分布称为<em>二项概率分布</em>。我们可以使用<code>Stats.binomial_rvs</code>函数模拟抛硬币的过程。假设抛硬币的概率为0.4，抛10次。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let _ =
  let toss = Array.make 10 0 in
  Array.map (fun _ -&gt; Stats.binomial_rvs 0.3 1) toss
&gt;- : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 1; 0|]
</code></pre>
</div>
<p>方程<span data-cites="eq:stats:binomial_pdf" class="citation">[@eq:stats:binomial_pdf]</span>称为此二项分布的<em>概率密度函数</em>（PDF）。形式上，随机变量X的PDF表示为<span class="math inline">\(p_X(k)\)</span>，定义为：</p>
<p><span class="math display">\[p_X(k)=P({s \in S | X(s) = k}),\]</span></p>
<p>其中<span class="math inline">\(S\)</span>是样本空间。这也可以用代码表示：</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let x = [|0; 1; 2; 3|]
&gt;val x : int array = [|0; 1; 2; 3|]
let p = Array.map (Stats.binomial_pdf ~p:0.3 ~n:3) x
&gt;val p : float array =
&gt;  [|0.342999999999999916; 0.440999999999999837; 0.188999999999999918;
&gt;    0.0269999999999999823|]
Array.fold_left (+.) 0. p
&gt;- : float = 0.999999999999999778
</code></pre>
</div>
<p>除了PDF之外，另一个相关且经常使用的想法是查看随机变量<span class="math inline">\(X\)</span>落在某个范围内的概率：<span class="math inline">\(P(a \leq X \leq b)\)</span>。它可以重写为<span class="math inline">\(P(X \leq b) - P(X \leq a - 1)\)</span>。这里术语<span class="math inline">\(P(X \leq t)\)</span>称为随机变量<span class="math inline">\(X\)</span>的<em>累积分布函数</em>。对于二项分布，它的CDF是：</p>
<p><span class="math display">\[p(X\leq~k)=\sum_{i=0}^k{N\choose i} p^k(1-p)^{n-i}.\]</span></p>
<p>我们可以再次使用代码计算3次抛硬币问题的CDF。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let x = [|0; 1; 2; 3|]
&gt;val x : int array = [|0; 1; 2; 3|]
let p = Array.map (Stats.binomial_cdf ~p:0.3 ~n:3) x
&gt;val p : float array = [|0.342999999999999972; 0.784; 0.973; 1.|]
</code></pre>
</div>
</section>
<section class="level3" id="continuous-random-variables">
<h3>连续随机变量</h3>
<p>与离散随机变量不同，连续随机变量有无限数量的可能结果。例如，在均匀分布中，我们可以选择0到1之间的一个随机实数。显然可以有无限数量的输出。</p>
<p>最广泛使用的连续分布之一无疑是<em>高斯分布</em>。它的概率函数是一个连续的函数：<span class="math display">\[p(x) = \frac{1}{\sqrt{2\pi~\delta}}e^{-\frac{1}{2}\left(\frac{t - \mu}{\sigma}\right)^2}\]</span> {#eq:stats:gaussian_pdf}</p>
<p>这里的<span class="math inline">\(\mu\)</span>和<span class="math inline">\(\sigma\)</span>是参数。根据它们，<span class="math inline">\(p(x)\)</span>可以采取不同的形状。让我们看一个例子。</p>
<p>在这个例子中，我们生成了两个数据集，都包含了从不同的高斯分布<span class="math inline">\(\mathcal{N} (\mu, \sigma^{2})\)</span>中抽取的999个点。对于第一个数据集，配置为<span class="math inline">\((\mu = 1, \sigma = 1)\)</span>；而对于第二个数据集，配置为<span class="math inline">\((\mu = 12, \sigma = 3)\)</span>。</p>
<div class="highlight">
<pre><code class="language-ocaml">let noise sigma = Stats.gaussian_rvs ~mu:0. ~sigma;;
let x = Array.init 999 (fun _ -&gt; Stats.gaussian_rvs ~mu:1. ~sigma:1.);;
let y = Array.init 999 (fun _ -&gt; Stats.gaussian_rvs ~mu:12. ~sigma:3.);;</code></pre>
</div>
<p>我们可以使用直方图绘制数据集，如下所示。在调用<code>histogram</code>时，我们还明确指定了30个bin。您还可以使用<code>spec</code>命名参数微调图形，以指定颜色、x范围、y范围等。我们将在单独的章节中详细讨论如何使用Owl绘图。</p>
<div class="highlight">
<pre><code class="language-ocaml">(* 将数组转换为矩阵 *)

let x' = Mat.of_array x 1 999;;
let y' = Mat.of_array y 1 999;;

(* 绘制图形 *)

let h = Plot.create ~m:1 ~n:2 "plot_02.png" in

Plot.subplot h 0 0;
Plot.set_ylabel h "频率";
Plot.histogram ~bin:30 ~h x';
Plot.histogram ~bin:30 ~h y';

Plot.subplot h 0 1;
Plot.set_ylabel h "PDF p(x)";
Plot.plot_fun ~h (fun x -&gt; Stats.gaussian_pdf ~mu:1. ~sigma:1. x) (-2.) 6.;
Plot.plot_fun ~h (fun x -&gt; Stats.gaussian_pdf ~mu:12. ~sigma:3. x) 0. 25.;

Plot.output h;;</code></pre>
</div>
<p>在子图1中，我们可以看到第二个数据集的分布范围更广。在子图2中，我们还绘制了两个数据集的概率密度函数。</p>
<figure>
<img style="width:90.0%" id="fig:stats:plot_02" alt="两个数据集的概率密度函数" title="plot 02" src="images/stats/plot_02.png"><figcaption>两个数据集的概率密度函数</figcaption>
</figure>
<p>高斯的CDF可以通过无限求和，即积分来计算：</p>
<p><span class="math display">\[p(x\leq~k)=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^k~e^{-t^2/2}dt.\]</span></p>
<p>我们可以使用<code>gaussian_cdf</code>观察这个函数。</p>
<div class="highlight">
<pre><code class="language-ocaml">let h = Plot.create "plot_gaussian_cdf.png" in
Plot.set_ylabel h "CDF";
Plot.plot_fun ~h ~spec:[ RGB (66,133,244); LineStyle 1; LineWidth 2.; Marker "*" ] (fun x -&gt; Stats.gaussian_cdf ~mu:1. ~sigma:1. x) (-2.) 6.;
Plot.plot_fun ~h ~spec:[ RGB (219,68,55);  LineStyle 2; LineWidth 2.; Marker "+" ] (fun x -&gt; Stats.gaussian_cdf ~mu:12. ~sigma:3. x) 0. 25.;
Plot.(legend_on h ~position:SouthEast [|"mu=1,sigma=1"; "mu=12, sigma=3"|]);
Plot.output h</code></pre>
</div>
<figure>
<img style="width:70.0%" id="fig:stats:plot_gaussian_cdf" alt="两个数据集的累积密度函数" title="plot gaussian cdf" src="images/stats/plot_gaussian_cdf.png"><figcaption>两个数据集的累积密度函数</figcaption>
</figure>
</section>
<section class="level3" id="descriptive-statistics">
<h3>描述性统计</h3>
<p>一个随机变量描述一个单独的事件。一整组对某些感兴趣的个体的集合称为<em>总体</em>。总体可以用多个描述性统计来描述。其中最常用的两个是<em>均值</em>和<em>方差</em>。总体的均值<span class="math inline">\(X\)</span>，具有<span class="math inline">\(n\)</span>个元素，定义为：</p>
<p><span class="math display">\[E(X) = \frac{1}{n}\sum_{i}x_i,\]</span> {#eq:stats:mean} 其中<span class="math inline">\(x_i\)</span>是总体中的第<span class="math inline">\(i\)</span>个元素。方差的定义类似：</p>
<p><span class="math display">\[Var(X) = \frac{1}{n}\sum_{i}(x_i - E(X))^2.\]</span> {#eq:stats:variance}</p>
<p>一个类似且常用的概念是<em>标准差</em>，它是方差的平方根。均值（或<em>期望值</em>）和方差的含义是很明显的，前者是总体的代表性中心值，后者是值围绕中心期望的分散程度。</p>
<p>这些定义是针对离散随机变量的，但它们可以很容易地扩展到连续情况。为了使其更一般，我们将实变量关于值<span class="math inline">\(X\)</span>的<em>n阶矩</em>定义为：</p>
<p><span class="math display">\[M_n(X) = \int_x~(x_i - c)^2~f(x_i)dx,\]</span> {#eq:stats:moment}</p>
<p>其中<span class="math inline">\(f(x)\)</span>是变量<span class="math inline">\(X\)</span>的连续函数，<span class="math inline">\(c\)</span>是某个常数。您可以看到，均值实际上是一阶矩，而方差是二阶矩。<br>
三阶矩称为<em>偏度</em>，表示实随机变量的概率分布的不对称性。四阶矩称为<em>峰度</em>，显示概率分布的“尾巴”有多长。</p>
<p>让我们看一个简单的例子。我们首先生成一百个在0到10之间均匀分布的随机数。在这里，我们使用<code>Stats.uniform_rvs</code>函数生成遵循均匀分布的数字。</p>
<div class="highlight">
<pre><code class="language-ocaml">let data = Array.init 100 (fun _ -&gt; Stats.uniform_rvs 0. 10.);;</code></pre>
</div>
<p>然后我们使用<code>mean</code>函数计算样本平均值。如预期的那样，它大约是5。我们还可以使用相应的函数轻松计算其他更高的矩。我们可以对这些结果进行一个非常粗糙而快速的解释。它具有广泛的分布（左右约3），根据非常小的偏度数字，分布不对称。最后，小的峰度表明分布没有明显的尾部。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Stats.mean data
&gt;- : float = 5.18160409659184573
Stats.std data
&gt;- : float = 2.92844832850280135
Stats.var data
&gt;- : float = 8.57580961271085229
Stats.skew data
&gt;- : float = -0.109699186612116223
Stats.kurtosis data
&gt;- : float = 1.75165078829330856
</code></pre>
</div>
<p>以下代码计算分布的不同中心矩。中心矩是关于随机变量均值的概率分布的矩。零阶中心矩始终为1，第一阶接近零，第二阶接近方差。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Stats.central_moment 0 data
&gt;- : float = 1.
Stats.central_moment 1 data
&gt;- : float = -3.13082892944294137e-15
Stats.central_moment 2 data
&gt;- : float = 8.49005151658374224
Stats.central_moment 3 data
&gt;- : float = -2.75496511397836663
</code></pre>
</div>
<p>除了矩之外，我们经常使用<em>顺序统计量</em>来了解数据。顺序统计量和秩统计量是非参数统计和推断中最基本的工具之一。统计样本的第<span class="math inline">\(k^{th}\)</span>顺序统计量等于它的第k小值。例如：</p>
<p>在Owl的<code>Stat</code>模块中有许多有序统计函数供您探索。其中一些最常用的如下所示：</p>
<div class="highlight">
<pre><code class="language-ocaml">Stats.min;;
Stats.max;;
Stats.median;;
Stats.quantile;;
Stats.first_quartile;;
Stats.third_quartile;;
Stats.percentile;;</code></pre>
</div>
<p><code>min</code>和<code>max</code>很容易使用。<code>median</code>是整个样本中排序列表中的中间数字。它有时比<code>mean</code>更能描述数据，因为后者更容易受到异常值的影响。</p>
<p>类似的概念是<code>quartile</code>：样本中有75%的测量值大于第一四分位数，有25%大于第三四分位数。<code>median</code>也是第二四分位数。更一般的概念是<code>percentile</code>，即总值中低于该度量的百分比。例如，第一四分位数也是第25百分位数。</p>
</section>
</section>
<section class="level2" id="special-distribution">
<h2>特殊分布</h2>
<p>所有分布都是平等的，但有些比其他分布更平等。在实践中，特定类型的特殊分布一次又一次地被使用，并被赋予特殊名称。下表列出了其中一小部分。</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">分布名称</th>
<th style="text-align: left;">PDF</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Gaussian distribution</td>
<td style="text-align: left;"><span class="math inline">\(\frac{1}{\sigma {\sqrt {2\pi }}}e^{-{\frac {1}{2}}\left({\frac {x-\mu }{\sigma }}\right)^{2}}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Gamma distribution</td>
<td style="text-align: left;"><span class="math inline">\(\frac{1}{\Gamma(k)\theta^k}x^{k-1}e^{-x\theta^-{1}}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Beta distribution</td>
<td style="text-align: left;"><span class="math inline">\(\frac{\Gamma(\alpha + \beta)}{\Gamma(\alpha)\Gamma(\beta)}x^{\alpha-1}(1-x)^{\beta-1}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Cauchy distribution</td>
<td style="text-align: left;"><span class="math inline">\((\pi~\gamma~(1 + (\frac{x-x_0}{\gamma})^2))^{-1}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Student’s <span class="math inline">\(t\)</span>-distribution</td>
<td style="text-align: left;"><span class="math inline">\(\frac{\Gamma((v+1)/2)}{\sqrt{v\pi}\Gamma(v/2)}(1 + \frac{x^2}{v})^{-\frac{v+1}{2}}\)</span></td>
</tr>
</tbody>
</table>
<p>在这里，<span class="math inline">\(\Gamma(x)\)</span> 是Gamma函数。这些不同类型的分布在Owl的<code>Stats</code>模块中得到支持。对于每个分布，都有一组以分布名称作为它们共同前缀的相关函数。例如，对于高斯分布，我们可以利用以下函数：</p>
<ul>
  <li><code>gaussian_rvs</code>：随机数生成器。</li>
  <li><code>gaussian_pdf</code>：概率密度函数。</li>
  <li><code>gaussian_cdf</code>：累积分布函数。</li>
  <li><code>gaussian_ppf</code>：百分点函数（CDF的反函数）。</li>
  <li><code>gaussian_sf</code>：生存函数（1 - CDF）。</li>
  <li><code>gaussian_isf</code>：逆生存函数（SF的反函数）。</li>
  <li><code>gaussian_logpdf</code>：对数概率密度函数。</li>
  <li><code>gaussian_logcdf</code>：对数累积分布函数。</li>
  <li><code>gaussian_logsf</code>：对数生存函数。</li>
</ul>
<p>Stats模块支持许多分布。对于每个分布，都有一组以分布名称作为它们共同前缀的相关函数。例如，下面的代码使用<code>gamma_pdf</code>绘制Gamma分布的概率密度函数。结果显示在<span data-cites="fig:stats:gamma_pdf" class="citation">[@fig:stats:gamma_pdf]</span>中。</p>
<div class="highlight">
<pre><code class="language-ocaml">  
module N = Dense.Ndarray.D

let _ =
  let x = N.linspace 0. 16. 100 in

  let f1 x = Owl_stats.gamma_pdf x ~shape:1. ~scale:2. in
  let f2 x = Owl_stats.gamma_pdf x ~shape:2. ~scale:2. in
  let f3 x = Owl_stats.gamma_pdf x ~shape:5. ~scale:1. in
  let f4 x = Owl_stats.gamma_pdf x ~shape:7.5 ~scale:1. in

  let y1 = N.map f1 x in
  let y2 = N.map f2 x in
  let y3 = N.map f3 x in
  let y4 = N.map f4 x in

  let h = Plot.create "gamma_pdf.png" in
  let open Plot in
  set_xlabel h "";
  set_ylabel h "";
  set_title h "Gamma分布概率密度函数";
  plot ~h ~spec:[ RGB (66, 133, 244); LineStyle 1; LineWidth 2. ] x y1;
  plot ~h ~spec:[ RGB (219, 68,  55); LineStyle 1; LineWidth 2. ] x y2;
  plot ~h ~spec:[ RGB (244, 180,  0); LineStyle 1; LineWidth 2. ] x y3;
  plot ~h ~spec:[ RGB (15, 157,  88); LineStyle 1; LineWidth 2. ] x y4;

  Plot.(legend_on h ~position:NorthEast [|"k=1, theta=2"; "k=2, theta=2"; "k=5, theta=1"; "k=7.5, theta=1"|]);

  output h</code></pre>
</div>
<figure>
<img style="width:60.0%" id="fig:stats:gamma_pdf" alt="Gamma分布的概率密度函数" title="gamma_pdf" src="images/stats/gamma_pdf.png"><figcaption>Gamma分布的概率密度函数</figcaption>
</figure>
</section>
<section class="level2" id="multiple-variables">
<h2>多变量</h2>
<p>到目前为止，我们谈论了单一随机变量，但问题通常涉及多个变量。例如，在数据中心中，如果我们知道服务器停止工作的概率，以及网络链接中断的概率，我们可能想考虑数据中心正常运行的概率。两个随机变量<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>的<em>联合概率</em>表示为<span class="math inline">\(p(X, Y)\)</span>或<span class="math inline">\(P(X~\cap~Y)\)</span>，表示两个事件同时发生的概率。</p>
<p>有一种特殊情况，其中联合概率易于计算。如果两个事件是<em>独立</em>的，即彼此不相关，则结果<span class="math inline">\(X=x\)</span>和<span class="math inline">\(Y=y\)</span>的概率为：</p>
<p><span class="math display">\[p(xy) = p(X=x \textrm{AND } Y=y) = p(X=x) \times p(Y=y) = p_X(x)p_Y(y).\]</span></p>
<p>另一个相关的概念是<em>条件概率</em>。直观地，现实世界中的许多事件并不是完全独立的。例如，考虑一个人穿雨衣的概率，以及一个人在<em>雨天</em>穿雨衣的概率。事件“穿雨衣”和“雨天”显然是相关的。形式上，给定事件B的情况下事件A的概率计算为：</p>
<p><span class="math display">\[P(X | Y) = \frac{P(X~\cap~Y)}{P(Y)}.\]</span></p>
<p>毫无疑问，条件概率最重要的应用之一是<em>贝叶斯定理</em>，最早由Thomas Bayes于1991年提出<span data-cites="bayes1991essay" class="citation">[@bayes1991essay]</span>。它的表达式如<span data-cites="eq:stats:bayes" class="citation">[@eq:stats:bayes]</span>所示，例如，它提供了在直接不可用时计算条件概率的方法。</p>
<p><span class="math display">\[P(X|Y) = \frac{P(Y|X)P(X)}{P(Y)}\]</span> {#eq:stats:bayes}</p>
<p>这个定理的一个强大应用是，它提供了根据观察到的证据校准对某事的知识的工具（“它有10%的可能性发生”）。例如，一个新手几乎无法判断骰子是否正常或加重。如果我向你展示一个骰子并问你估计这个骰子是伪造的概率，你可能会说“嗯，我不知道，也许10%”。定义事件<span class="math inline">\(X\)</span>为“骰子被加载”，并将概率先验设置为<span class="math inline">\(P(X) = 0.1\)</span>。现在我开始连续投掷三次，不知何故，我得到了三个6。现在我再次问你，在<em>你刚刚观察到的证据</em>的基础上，再次估计骰子被加载的概率。将事件<span class="math inline">\(Y\)</span>定义为“连续投掷的所有三次都得到了6”。</p>
<p>我们可以轻松计算在正常情况下<span class="math inline">\(P(Y) = 1 / 6^3 \approx 0.005\)</span>，并且这个“正常情况”发生的概率根据我们先前的知识是90%。<br>
总体而言，<span class="math inline">\(P(Y) = P(Y|X)P(X) + P(Y|X')P(X')\)</span>，其中<span class="math inline">\(P(X')\)</span>表示骰子是正常的概率。此外，我们可以说，如果骰子被加载，则得到所有6的概率<span class="math inline">\(P(Y | X)\)</span>会相当高，例如0.99。因此，我们可以计算，现在考虑到观察到的证据，骰子被加载的概率为<span class="math inline">\(P(X|Y) = \frac{0.99 \times 0.1}{0.99~\times~0.1 + 0.005~\times~0.9} \approx 0.96\)</span>。这是在观察证据后得到的<strong>后验概率</strong>，显著改进了我们之前的知识。这个过程可以广泛应用于许多科学领域，在这些领域中，现有的理论或知识经常受到新证据的检验。</p>
</section>
<section class="level2" id="sampling">
<h2>抽样</h2>
<p>我们已经讨论过使用随机变量来描述感兴趣的某些事件。所有个体构成了<em>总体</em>。它可以用我们之前展示过的均值、标准差等统计数据来描述。然而，在现实世界中，大多数总体很难甚至不可能枚举。例如，如果我们想知道地球上所有沙子的平均重量，那么逐个测量它们肯定是困难的。相反，需要一个<em>样本</em>来代表这个总体。</p>
<section class="level3" id="unbiased-estimator">
<h3>无偏估计</h3>
<p>有多种抽样方法。随机抽样是一个常见选择。类似的方法是“分层随机抽样”，它首先将总体分成几个组，然后在每个组内随机选择。例如，在设计问卷调查时，你希望各个年龄组的人都能得到平等代表，那么分层随机抽样就是一种更合适的方法。当然，只要样本具有代表性，也有其他合理的抽样方法，这意味着总体中的任何成员被选入样本的可能性是相等的。</p>
<p>在选择适当的样本之后，下一步是用样本描述总体。诸如均值和方差等统计数据仍然非常有用，但我们能否直接使用样本的统计数据并声明它们也可以用来代表整个总体呢？事实上，这取决于统计数据是否是一个<em>无偏估计</em>，即其值的期望值是相应的总体参数。</p>
<p>例如，让我们取一个包含<span class="math inline">\(n\)</span>个元素的样本，其均值为<span class="math inline">\(m\)</span>：</p>
<p><span class="math display">\[m = \frac{1}{n}\sum_{i=1}^n~x_i,\]</span></p>
<p>其中<span class="math inline">\(x_i\)</span>是样本中的一个元素。将总体表示为<span class="math inline">\(\mu\)</span>，可以进一步证明：<span class="math inline">\(E(m) = \mu\)</span>。因此，样本均值是总体的无偏估计。</p>
<p>方差就不能这样说了。样本方差为：</p>
<p><span class="math display">\[v = \frac{1}{n}\sum_{i=1}^n(x_i - m)^2.\]</span></p>
<p>假设总体的方差为<span class="math inline">\(\sigma^2\)</span>，则可以证明<span class="math inline">\(E(v) = \frac{n - 1}{n}\sigma^2\)</span>。因此，总体方差的无偏估计不是样本的<span class="math inline">\(v\)</span>，而是<span class="math inline">\(\frac{n}{n-1}v\)</span>。</p>
</section>
<section class="level3" id="inferring-population-parameters">
<h3>推断总体参数</h3>
<p>在前一节中，我们已经展示了如何在给定来自总体的样本的情况下得到均值和方差的期望值。但我们也许需要了解的不仅仅是期望值。例如，我们能否确定一个区间，我们可以相当确信总体均值位于其中？本节探讨了这个问题。</p>
<p>首先，我们需要解释<em>中心极限定理</em>。它指出，如果你有一个总体，并从总体中取足够大的随机样本（带有替换），则样本均值的分布将近似正态分布。如果样本大小足够大（如<span class="math inline">\(n \lt 20\)</span>），无论总体分布如何，该定理都成立。</p>
<p>具体而言，假设我们反复从相同大小的子集中抽样，然后我们可以定义随机变量<span class="math inline">\(X\)</span>表示每个抽样子集的均值。根据中心极限定理，可以推导出，假设总体的均值为<span class="math inline">\(\mu\)</span>，方差为<span class="math inline">\(\sigma^2\)</span>，均未知，那么<span class="math inline">\(X\)</span>遵循均值为<span class="math inline">\(\mu\)</span>，方差为<span class="math inline">\(\frac{\sigma^2}{n}\)</span>的正态分布。</p>
<p>由于总体的均值和方差都是未知的，显然我们不能同时解决这两个未知数。为了更精确地估计总体均值<span class="math inline">\(\mu\)</span>，让我们首先假设可以直接用样本方差计算总体方差：<span class="math inline">\(\sigma^2 = \frac{1}{n-1}\sum_{i=1}^n(x_i - m)^2\)</span>。这个假设在实践中是合理的，当<span class="math inline">\(n\)</span>足够大时。</p>
<p>既然我们知道<span class="math inline">\(X\)</span>遵循正态分布，我们可以利用其中的一些好的性质。例如，我们知道概率质量的95%位于均值的1.96标准差之内。我们可以使用正态分布的CDF函数来验证这一点：</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let f = Stats.gaussian_cdf ~mu:0. ~sigma:1. in
f 1.96 -. f (-1.96)
&gt;- : float = 0.950004209703559
</code></pre>
</div>
<p>因此，对于<span class="math inline">\(X\)</span>中的任何值<span class="math inline">\(x\)</span>，我们知道：<span class="math display">\[P(\mu - 1.96~\frac{\sigma}{\sqrt{n}} \le x \le  \mu + 1.96~\frac{\sigma}{\sqrt{n}}).\]</span></p>
<p>稍作变化，它变成了：</p>
<p><span class="math display">\[P( x - 1.96~\frac{\sigma}{\sqrt{n}} \le \mu \le  x + 1.96~\frac{\sigma}{\sqrt{n}}).\]</span></p>
<p>这意味着在给定样本均值 <span class="math inline">\(m\)</span> 的情况下，总体均值 <span class="math inline">\(\mu\)</span> 位于这个范围内 [ <span class="math inline">\(m - 1.96~\frac{\sigma}{\sqrt{n}}\)</span>, <span class="math inline">\(m + 1.96~\frac{\sigma}{\sqrt{n}}\)</span> ] 的概率为 95%。这被称为其<em>置信区间</em>。同样，总体方差 <span class="math inline">\(\sigma^2\)</span> 直接使用样本的无偏估计。</p>
<p>让我们回到 <em>1.96</em> 这个数字。我们使用这个范围是因为假设 <span class="math inline">\(X\)</span> 遵循正态分布。变量 <span class="math inline">\(\frac{x - \mu}{\sigma/\sqrt{n}}\)</span> 遵循标准正态分布。它被称为<em>标准 Z 变量</em>。我们可以查看标准正态分布表，找到对应于 95% 置信水平的范围。然而，正如我们所解释的，当 <span class="math inline">\(n\)</span> 较小时，这并不成立，因为我们实际上使用的是 <span class="math inline">\(\frac{x-\mu}{\sqrt{\frac{\sum_{i}(x - m)^2}{n(n-1)}}}\)</span> 而不是真正的 <span class="math inline">\(z\)</span> 变量。后者被称为<em>标准 t 变量</em>，它遵循自由度为 <span class="math inline">\(n-1\)</span> 的 t 分布。当 <span class="math inline">\(n\)</span> 很大时，t 分布几乎与正态分布相同。因此，如果 <span class="math inline">\(n\)</span> 较小，我们需要查阅 t 表。例如，如果 <span class="math inline">\(n=17\)</span>，则范围参数约为 2.12，可以验证为：</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let f x = Stats.t_cdf x ~df:16. ~loc:0. ~scale:1. in 
f 2.12 -. f (-2.12)
&gt;- : float = 0.950009071286895823
</code></pre>
</div>
<p>这就是总体均值的全部内容。总体方差范围的估计使用 <span class="math inline">\(\chi\)</span>-square 分布，但在实践中很少使用。因此，在本节中我们省略了它。</p>
</section>
</section>
<section class="level2" id="hypothesis-tests">
<h2>假设检验</h2>
<section class="level3" id="theory">
<h3>理论</h3>
<p>虽然描述性统计只关注观察数据的属性，统计推断着重于研究数据集是否是从一个更大的总体中抽样的。换句话说，统计推断对总体提出了假设。假设检验是推断性统计分析中的一种重要方法。</p>
<p>让我们考虑经典的抛硬币实验。假设我们有一个基本假设/假设，即大多数硬币在投掷时可以以50/50的概率出现正面或反面。现在，如果你抛一枚硬币3次，得到3个正面，你能否声称这枚硬币不是一枚正常的硬币？以多大的概率？另一个例子是，假设你声称你提出的算法提高了最先进的运行速度，你有两个关于使用两种不同算法的执行时间的样本，然后你如何确信你的声明是合理的。这就是我们需要假设检验的地方。</p>
<p>关于数据集之间的统计关系，提出了两个假设。</p>
<ul>
<li>零假设 <span class="math inline">\(H_0\)</span>：两个数据集之间没有关系。</li>
<li>备择假设 <span class="math inline">\(H_1\)</span>：两个数据集之间存在统计显著关系。</li>
</ul>
<p>在假设成立的情况下，出现某个结果的概率称为其 p 值。在实践中，p 值被设定为 5%（1% 也经常使用）。例如，如果我们相信一枚硬币是正常的，但实验结果只有很低的概率，比如 0.03，我们可以在 5% 的置信水平下拒绝这个假设（“这枚硬币是正常的”）。</p>
<p>请注意，如果我们不拒绝一个假设，并不意味着它被接受。如果我们抛硬币三次得到三个正面。在假设这枚硬币是正常的情况下，这个结果的概率是 12.5%，因此我们不能拒绝这个假设。<br>
不拒绝并不意味着我们非常确定硬币完全没有偏倚。因此，在选择假设时需要非常小心。<span class="math inline">\(H_0\)</span> 应该是我们认为足够坚实以解释数据的东西，除非被观察到的数据强烈挑战。此外，将零假设尽可能明确地表述也有助于使其尽可能不可否认。</p>
</section>
<section class="level3" id="gaussian-distribution-in-hypothesis-testing">
<h3>在假设检验中的正态分布</h3>
<p>最常见的测试之一是查看观察数据是否来自某个正态分布。这被称为“z-测试”。现在让我们看看如何在 Owl 中执行 z-测试。我们首先生成两个数据集，两者都是从正态分布中抽取的，但参数不同。第一个 <code>data_0</code> 从 <span class="math inline">\(\mathcal{N}(0, 1)\)</span> 抽取，而第二个 <code>data_1</code> 从 <span class="math inline">\(\mathcal{N}(3, 1)\)</span> 抽取。</p>
<div class="highlight">
<pre><code class="language-ocaml">let data_0 = Array.init 10 (fun _ -&gt; Stats.gaussian_rvs ~mu:0. ~sigma:1.);;
let data_1 = Array.init 10 (fun _ -&gt; Stats.gaussian_rvs ~mu:3. ~sigma:1.);;</code></pre>
</div>
<p>我们的假设是数据集是从正态分布 <span class="math inline">\(\mathcal{N}(0, 1)\)</span> 中抽取的。从我们生成合成数据的方式来看，显然 <code>data_0</code> 将通过测试，但让我们看看 Owl 是否会使用其 <code>Stats.z_test</code> 函数测试我们。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Stats.z_test ~mu:0. ~sigma:1. data_0
&gt;- : Owl_stats.hypothesis =
&gt;{Owl.Stats.reject = false; p_value = 0.289340080583773251;
&gt; score = -1.05957041132113083}
</code></pre>
</div>
<p>返回的结果是以下类型定义的记录。字段是自说明的：<code>reject</code> 字段告诉我们是否拒绝零假设，以及使用给定数据集计算的 p 值和分数。</p>
<div class="highlight">
<pre><code class="language-ocaml">type hypothesis = {
  reject : bool;
  p_value : float;
  score : float;
}</code></pre>
</div>
<p>从前面的结果中，我们可以看到 <code>reject = false</code>，表示拒绝零假设，因此数据集 <code>data_0</code> 是从 <span class="math inline">\(\mathcal{N}(0, 1)\)</span> 中抽取的。那么第二个数据集呢？</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Stats.z_test ~mu:0. ~sigma:1. data_1
&gt;- : Owl_stats.hypothesis =
&gt;{Owl.Stats.reject = true; p_value = 5.06534675819424548e-23;
&gt; score = 9.88035435799393547}
</code></pre>
</div>
<p>正如我们预期的那样，零假设在一个非常小的p值下被接受。这表明<code>data_1</code>不是从假定的<span class="math inline">\(\mathcal{N}(0, 1)\)</span>分布中抽取的。</p>
<p>在前一节中，我们介绍了z变量和t变量。除了z检验之外，另一种经常使用的测试是检查在零假设下给定的数据是否遵循学生t分布。在<code>Stats</code>模块中，<code>t_test ~mu ~alpha ~side x</code>函数返回t检验的测试决策，这是当总体标准差未知时位置参数的参数测试。这里<code>mu</code>是总体均值，<code>alpha</code>是显著性水平。</p>
</section>
<section class="level3" id="two-sample-inferences">
<h3>双样本推断</h3>
<p>另一种常见的测试类型是测试两个样本是否来自同一总体。例如，我们需要测试对算法的改进是否真的有效。默认的零假设是，两个样本是从同一总体中抽取的。测试策略取决于样本大小。</p>
<p>如果两个样本的大小相同，那么可以通过逐个相减两个集合中的元素来简化测试。测试然后变成检查结果集是否来自均值为0的总体。这个问题可以使用前一节介绍的方法通过使用t检验来解决。具体而言，我们提供了配对样本t检验函数。<code>t_test_paired ~alpha ~side x y</code>返回一个测试决策，用于零假设，即<code>x – y</code>中的数据来自均值为零且方差未知的正态分布。</p>
<p>当这两个子集的大小不相同时，问题变得更加复杂。然后，我们需要讨论关于它们的置信区间的两种情况。如果两个区间都不重叠，显然我们可以相当肯定两个样本来自不同的总体，因此拒绝零假设。如果区间重叠，我们需要确保其他一些条件成立。例如，如果我们可以假设两个总体的方差相同，那么可以证明变量：</p>
<p><span class="math display">\[\frac{\bar{x} - \bar{y}}{\sqrt{\frac{\sum_{i=1}^a~(x_i - \bar{x})^2 + \sum_{i=1}^b~(y_i - \bar{y})^2}{a + b - 2}(\frac{1}{a} + \frac{1}{b})}},\]</span></p>
<p>是一个具有<span class="math inline">\(a + b - 2\)</span>自由度的标准t变量，其中<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>是样本<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>的长度。</p>
<p>这个想法被实现为不配对样本t检验。函数<code>t_test_unpaired ~alpha ~side ~equal_var x y</code>返回一个测试决策，用于零假设，即向量<code>x</code>和<code>y</code>中的数据来自具有相等均值和相等但未知方差的独立正态分布的随机样本。这里<code>equal_var</code>指示两个样本是否具有相同的方差。如果两个方差不同，我们需要使用<em>非参数测试</em>，如Welche的t检验。</p>
</section>
<section class="level3" id="other-types-of-test">
<h3>其他测试类型</h3>
<p>除了我们到目前为止提到的内容之外，Owl中的<code>Stats</code>模块还支持许多其他不同类型的假设检验。本节将对它们进行简要介绍。</p>
<ul>
<li><p>Kolmogorov-Smirnov测试：<code>ks_test ~alpha x f</code>返回一个测试决策，用于零假设，即向量<code>x</code>中的数据来自具有CDF f的分布的独立随机样本。备择假设是<code>x</code>中的数据来自不同的分布。结果<code>(h,p,d)</code>：<code>d</code>是Kolmogorov-Smirnov测试统计量。</p></li>
<li><p>双样本Kolmogorov-Smirnov测试：<code>ks2_test ~alpha x y</code>返回一个测试决策，用于零假设，即向量<code>x</code>和<code>y</code>中的数据来自相同分布的独立随机样本。</p></li>
<li><p>卡方方差测试<code>var_test ~alpha ~side ~variance x</code>返回一个测试决策，用于零假设，即<code>x</code>中的数据来自具有输入<code>variance</code>的正态分布，使用卡方方差测试。备择假设是<code>x</code>来自具有不同方差的正态分布。</p></li>
<li><p>Jarque-Bera测试<code>jb_test ~alpha x</code>返回一个测试决策，用于零假设，即数据<code>x</code>来自具有未知均值和方差的正态分布，使用Jarque-Bera测试。</p></li>
<li><p>Wald–Wolfowitz Runs测试<code>runs_test ~alpha ~v x</code>返回一个测试决策，用于零假设，即数据<code>x</code>是随机排序的，反对它们不是，通过运行Wald–Wolfowitz测试。该测试基于连续值在均值上方或下方的运行的数量。<code>~v</code>是参考值，默认值是<code>x</code>的中位数。</p></li>
<li><p>Mann-Whitney秩测试<code>mannwhitneyu ~alpha ~side x y</code>对样本x和y执行Mann-Whitney秩测试。如果每个样本的长度小于10且没有结合，则使用精确测试，否则使用渐近正态分布。</p></li>
</ul>
</section>
</section>
<section class="level2" id="covariance-and-correlations">
<h2>协方差和相关性</h2>
<p>相关性研究了两个变量之间的关系强度。有不同的计算相关性的方法。首先，让我们看看Pearson相关性。</p>
<p><code>x</code>是我们的解释变量，我们从0到10的区间中均匀抽取了50个随机值。<code>y</code>和<code>z</code>都是与<code>x</code>线性相关的响应变量。唯一的区别是我们向响应变量添加了不同水平的噪声。噪声值是从高斯分布生成的。</p>
<div class="highlight">
<div class="highlight">
<pre><code class="language-ocaml">let noise sigma = Stats.gaussian_rvs ~mu:0. ~sigma;;
let x = Array.init 50 (fun _ -&gt; Stats.uniform_rvs 0. 10.);;
let y = Array.map (fun a -&gt; 2.5 *. a +. noise 1.) x;;
let z = Array.map (fun a -&gt; 2.5 *. a +. noise 8.) x;;</code></pre>
</div>
<p>从图形上更容易看出两个变量之间的关系。在这里，我们使用 Owl 的 Plplot 模块制作两个散点图。</p>
<div class="highlight">
<pre><code class="language-ocaml">(* 将数组转换为矩阵 *)

let x' = Mat.of_array x 1 50;;
let y' = Mat.of_array y 1 50;;
let z' = Mat.of_array z 1 50;;

(* 绘制图形 *)

let h = Plot.create ~m:1 ~n:2 "plot_01.png" in

  Plot.subplot h 0 0;
  Plot.set_xlabel h "x";
  Plot.set_ylabel h "y (sigma = 1)";
  Plot.scatter ~h x' y';

  Plot.subplot h 0 1;
  Plot.set_xlabel h "x";
  Plot.set_ylabel h "z (sigma = 8)";
  Plot.scatter ~h x' z';

  Plot.output h;;</code></pre>
</div>
<p>子图 1 显示了<code>x</code>和<code>y</code>之间的函数关系，而子图 2 显示了<code>x</code>和<code>z</code>之间的关系。由于我们向<code>z</code>添加了更高级别的噪声，第二个图中的点更加分散。</p>
<figure>
<img style="width:90.0%" id="fig:stats:plot_01" alt="x和另外两个变量之间的函数关系。" title="plot 01" src="images/stats/plot_01.png"><figcaption><code>x</code>和另外两个变量之间的函数关系。</figcaption>
</figure>
<p>直观地，我们很容易从图表中看出<code>x</code>和<code>y</code>之间存在更强的关系。但在数值上呢？在许多情况下，数字更受欢迎，因为它们更容易被计算机比较。以下代码片段计算了<code>x</code>和<code>y</code>之间的Pearson相关性，以及<code>x</code>和<code>z</code>之间的相关性。正如我们所看到的，较小的相关性值表明与<code>x</code>和<code>z</code>之间的线性关系相比，<code>x</code>和<code>y</code>之间的关系更弱。</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Stats.corrcoef x y
&gt;- : float = 0.991145445979576656
Stats.corrcoef x z
&gt;- : float = 0.692163016204755288
</code></pre>
</div>
</section>
<section class="level2" id="summary">
<h2>总结</h2>
<p>在本章中，我们简要介绍了概率和统计学中的一些主要主题。随机变量和不同类型的分布是本章的两个基石。基于它们，我们介绍了在存在多个变量时的联合和条件概率。这里的一个重要主题是贝叶斯定理。然后，我们从描述统计学转向推断统计学，并介绍了抽样，包括基于给定样本的无偏总体估计的概念，以及如何推断总体参数，如均值。接下来，我们用例子介绍了假设检验的基本思想。还讨论了协方差和相关性之间的差异。</p>
</section>
<section class="level2" id="references">
<h2>参考文献</h2>
</section>
</section>
</article></div><a href="ndarray.html" class="next-chapter"><div class="content"><h1><small>下一章：第06章</small>N维数组</h1></div></a><footer><div class="content"><ul><li><a href="http://ocaml.xyz/privacy.html">隐私政策</a></li><li><a href="https://github.com/ryanrhymes">GitHub</a></li></ul><p>版权所有 2017-2023 Liang Wang。</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script></body></html>
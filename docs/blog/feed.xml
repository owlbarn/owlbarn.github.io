<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="/blog/" rel="alternate" type="text/html" /><updated>2023-11-22T23:55:31+02:00</updated><id>/blog/feed.xml</id><title type="html">Algorithm Blog</title><subtitle>A collection of classic algorithms, written in OCaml.</subtitle><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><entry><title type="html">Insertion Sort</title><link href="/blog/algorithm/2023/11/20/insertion-sort.html" rel="alternate" type="text/html" title="Insertion Sort" /><published>2023-11-20T23:15:00+02:00</published><updated>2023-11-20T23:15:00+02:00</updated><id>/blog/algorithm/2023/11/20/insertion-sort</id><content type="html" xml:base="/blog/algorithm/2023/11/20/insertion-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of insertion sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">insertion_sort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">insertion_sort</span> <span class="n">xs</span><span class="p">)</span>  
<span class="ow">and</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>  
  <span class="o">|</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">ys</span>  
</code></pre></div></div>

<p>This implementation uses a recursive function to sort the list. The <code class="language-plaintext highlighter-rouge">insertion_sort</code> function takes a list as input and returns a sorted list. The <code class="language-plaintext highlighter-rouge">insert</code> function takes an element <code class="language-plaintext highlighter-rouge">x</code> and a sorted list as input and returns a new sorted list with <code class="language-plaintext highlighter-rouge">x</code> inserted in the correct position.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>The <code class="language-plaintext highlighter-rouge">insertion_sort</code> function is called with a list as input.</li>
  <li>If the list is empty, an empty list is returned.</li>
  <li>Otherwise, the first element <code class="language-plaintext highlighter-rouge">x</code> is removed from the list and the <code class="language-plaintext highlighter-rouge">insert</code> function is called with <code class="language-plaintext highlighter-rouge">x</code> and the sorted list returned by a recursive call to <code class="language-plaintext highlighter-rouge">insertion_sort</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">insert</code> function takes <code class="language-plaintext highlighter-rouge">x</code> and a sorted list as input.</li>
  <li>If the list is empty, a list with <code class="language-plaintext highlighter-rouge">x</code> as the only element is returned.</li>
  <li>Otherwise, the first element <code class="language-plaintext highlighter-rouge">y</code> is removed from the list and the <code class="language-plaintext highlighter-rouge">insert</code> function is called recursively with <code class="language-plaintext highlighter-rouge">x</code> and the remaining list <code class="language-plaintext highlighter-rouge">ys</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">x</code> is less than <code class="language-plaintext highlighter-rouge">y</code>, a new list with <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> followed by <code class="language-plaintext highlighter-rouge">ys</code> is returned.</li>
  <li>Otherwise, a new list with <code class="language-plaintext highlighter-rouge">y</code> followed by the result of calling <code class="language-plaintext highlighter-rouge">insert</code> with <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">ys</code> is returned.</li>
  <li>The sorted list returned by <code class="language-plaintext highlighter-rouge">insert</code> is returned by <code class="language-plaintext highlighter-rouge">insertion_sort</code>.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high. Implementation Here is an implementation of insertion sort in OCaml: let rec insertion_sort = function | [] -&gt; [] | x :: xs -&gt; insert x (insertion_sort xs) and insert x = function | [] -&gt; [x] | y :: ys -&gt; if x &lt; y then x :: y :: ys else y :: insert x ys This implementation uses a recursive function to sort the list. The insertion_sort function takes a list as input and returns a sorted list. The insert function takes an element x and a sorted list as input and returns a new sorted list with x inserted in the correct position. Step-by-step Explanation The insertion_sort function is called with a list as input. If the list is empty, an empty list is returned. Otherwise, the first element x is removed from the list and the insert function is called with x and the sorted list returned by a recursive call to insertion_sort. The insert function takes x and a sorted list as input. If the list is empty, a list with x as the only element is returned. Otherwise, the first element y is removed from the list and the insert function is called recursively with x and the remaining list ys. If x is less than y, a new list with x and y followed by ys is returned. Otherwise, a new list with y followed by the result of calling insert with x and ys is returned. The sorted list returned by insert is returned by insertion_sort. Complexity Analysis The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory.]]></summary></entry><entry><title type="html">Radix Sort</title><link href="/blog/algorithm/2023/11/20/radix-sort.html" rel="alternate" type="text/html" title="Radix Sort" /><published>2023-11-20T23:15:00+02:00</published><updated>2023-11-20T23:15:00+02:00</updated><id>/blog/algorithm/2023/11/20/radix-sort</id><content type="html" xml:base="/blog/algorithm/2023/11/20/radix-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Radix sort is a sorting algorithm that sorts elements by grouping them based on their digits or bits. It is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping the keys by individual digits that share the same significant position and value. Radix sort is often used for sorting large numbers of records, such as in big data applications.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of radix sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">radix_sort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="n">arr</span> <span class="n">exp</span> <span class="o">=</span>  
    <span class="k">if</span> <span class="n">exp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">arr</span> <span class="k">else</span>  
      <span class="k">let</span> <span class="n">zeroes</span><span class="o">,</span> <span class="n">ones</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">partition</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="ow">land</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">lsl</span> <span class="n">exp</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">arr</span> <span class="k">in</span>  
      <span class="n">loop</span> <span class="n">zeroes</span> <span class="p">(</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">loop</span> <span class="n">ones</span> <span class="p">(</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  
  <span class="k">in</span>  
  <span class="n">loop</span> <span class="n">arr</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">m</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">max</span> <span class="n">m</span> <span class="p">(</span><span class="n">int_of_float</span> <span class="p">(</span><span class="n">log10</span> <span class="p">(</span><span class="n">float_of_int</span> <span class="n">x</span><span class="p">))))</span> <span class="mi">0</span> <span class="n">arr</span><span class="p">)</span>  
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">radix_sort</code> takes in an array of integers <code class="language-plaintext highlighter-rouge">arr</code> and returns a sorted array. The <code class="language-plaintext highlighter-rouge">loop</code> function recursively sorts the array by partitioning it into two subarrays based on the value of the <code class="language-plaintext highlighter-rouge">exp</code>-th bit (starting from the most significant bit). The <code class="language-plaintext highlighter-rouge">exp</code> parameter is initially set to the maximum number of digits in any element of the array. The function <code class="language-plaintext highlighter-rouge">log10</code> is used to calculate the number of digits in each element.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Find the maximum number of digits in any element of the array.</li>
  <li>For each bit position starting from the most significant bit, partition the array into two subarrays based on the value of that bit.</li>
  <li>Recursively sort each subarray by repeating step 2 with the next bit position.</li>
  <li>Concatenate the sorted subarrays to get the final sorted array.</li>
</ol>

<p>For example, let’s say we have the following array:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[170, 45, 75, 90, 802, 24, 2, 66]  
</code></pre></div></div>

<p>The maximum number of digits is 3, so we start by partitioning the array based on the third bit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[170, 90, 802, 2, 24, 45, 75, 66]  
</code></pre></div></div>

<p>We then recursively sort each subarray by partitioning based on the second bit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[802, 2, 24, 45, 66, 170, 75, 90]  
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[2, 24, 45, 66, 75, 90, 170, 802]  
</code></pre></div></div>

<p>Finally, we concatenate the sorted subarrays to get the final sorted array:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[2, 24, 45, 66, 75, 90, 170, 802]  
</code></pre></div></div>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of radix sort is O(d * (n + k)), where d is the maximum number of digits in any element of the array, n is the number of elements in the array, and k is the range of values (i.e., the maximum value minus the minimum value). The space complexity is O(n + k).</p>

<p>In the worst case, when d is very large, radix sort can be slower than comparison-based sorting algorithms like quicksort or mergesort. However, radix sort has the advantage of being able to sort large integers and other non-comparable data types that cannot be easily sorted using comparison-based algorithms.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Radix sort is a sorting algorithm that sorts elements by grouping them based on their digits or bits. It is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping the keys by individual digits that share the same significant position and value. Radix sort is often used for sorting large numbers of records, such as in big data applications. Implementation Here is an implementation of radix sort in OCaml: let radix_sort arr = let rec loop arr exp = if exp &lt; 0 then arr else let zeroes, ones = List.partition (fun x -&gt; x land (1 lsl exp) = 0) arr in loop zeroes (exp - 1) @ loop ones (exp - 1) in loop arr (List.fold_left (fun m x -&gt; max m (int_of_float (log10 (float_of_int x)))) 0 arr) Here, radix_sort takes in an array of integers arr and returns a sorted array. The loop function recursively sorts the array by partitioning it into two subarrays based on the value of the exp-th bit (starting from the most significant bit). The exp parameter is initially set to the maximum number of digits in any element of the array. The function log10 is used to calculate the number of digits in each element. Step-by-step Explanation Find the maximum number of digits in any element of the array. For each bit position starting from the most significant bit, partition the array into two subarrays based on the value of that bit. Recursively sort each subarray by repeating step 2 with the next bit position. Concatenate the sorted subarrays to get the final sorted array. For example, let’s say we have the following array: [170, 45, 75, 90, 802, 24, 2, 66] The maximum number of digits is 3, so we start by partitioning the array based on the third bit: [170, 90, 802, 2, 24, 45, 75, 66] We then recursively sort each subarray by partitioning based on the second bit: [802, 2, 24, 45, 66, 170, 75, 90] [2, 24, 45, 66, 75, 90, 170, 802] Finally, we concatenate the sorted subarrays to get the final sorted array: [2, 24, 45, 66, 75, 90, 170, 802] Complexity Analysis The time complexity of radix sort is O(d * (n + k)), where d is the maximum number of digits in any element of the array, n is the number of elements in the array, and k is the range of values (i.e., the maximum value minus the minimum value). The space complexity is O(n + k). In the worst case, when d is very large, radix sort can be slower than comparison-based sorting algorithms like quicksort or mergesort. However, radix sort has the advantage of being able to sort large integers and other non-comparable data types that cannot be easily sorted using comparison-based algorithms.]]></summary></entry><entry><title type="html">Merge Sort</title><link href="/blog/algorithm/2023/11/20/mergesort.html" rel="alternate" type="text/html" title="Merge Sort" /><published>2023-11-20T23:01:00+02:00</published><updated>2023-11-20T23:01:00+02:00</updated><id>/blog/algorithm/2023/11/20/mergesort</id><content type="html" xml:base="/blog/algorithm/2023/11/20/mergesort.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Merge sort is a divide-and-conquer algorithm that sorts an array or list of elements by recursively dividing it into two halves, sorting each half, and then merging the sorted halves back together. It is a highly efficient sorting algorithm with a time complexity of O(n log n), making it suitable for large datasets. Merge sort is widely used in various applications, including sorting large databases, numerical analysis, and parallel computing.</p>

<h2 id="implementation">Implementation</h2>

<p>Here is an implementation of merge sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">merge_sort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>  
  <span class="o">|</span> <span class="n">xs</span> <span class="o">-&gt;</span>  
      <span class="k">let</span> <span class="k">rec</span> <span class="n">split</span> <span class="n">left</span> <span class="n">right</span> <span class="o">=</span> <span class="k">function</span>  
        <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span>  
        <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">split</span> <span class="n">right</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">left</span><span class="p">)</span> <span class="n">xs</span>  
      <span class="k">in</span>  
      <span class="k">let</span> <span class="k">rec</span> <span class="n">merge</span> <span class="n">left</span> <span class="n">right</span> <span class="o">=</span> <span class="k">match</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="k">with</span>  
        <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">right</span>  
        <span class="o">|</span> <span class="n">_</span><span class="o">,</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">left</span>  
        <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span>  
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">merge</span> <span class="n">xs</span> <span class="n">right</span>  
            <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">merge</span> <span class="n">left</span> <span class="n">ys</span>  
      <span class="k">in</span>  
      <span class="k">let</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">split</span> <span class="bp">[]</span> <span class="bp">[]</span> <span class="n">xs</span> <span class="k">in</span>  
      <span class="n">merge</span> <span class="p">(</span><span class="n">merge_sort</span> <span class="n">left</span><span class="p">)</span> <span class="p">(</span><span class="n">merge_sort</span> <span class="n">right</span><span class="p">)</span>  
</code></pre></div></div>

<p>Here is an example of using this implementation to sort a list of integers:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">sorted_list</span> <span class="o">=</span> <span class="n">merge_sort</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">5</span><span class="p">];;</span>  
</code></pre></div></div>

<p>The resulting <code class="language-plaintext highlighter-rouge">sorted_list</code> will be <code class="language-plaintext highlighter-rouge">[1; 2; 3; 4; 5; 6; 7]</code>.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">merge_sort</code> function takes a list of elements as input.</li>
  <li>If the list is empty or contains only one element, it is already sorted, so the function returns the list as is.</li>
  <li>Otherwise, the function recursively divides the list into two halves using the <code class="language-plaintext highlighter-rouge">split</code> function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">split</code> function takes two empty lists (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) and the original list as input.</li>
  <li>If the original list is empty, the function returns the two half lists.</li>
  <li>Otherwise, the function takes the first element of the original list and adds it to the <code class="language-plaintext highlighter-rouge">right</code> list, while the rest of the list is recursively split with the <code class="language-plaintext highlighter-rouge">right</code> list becoming the new <code class="language-plaintext highlighter-rouge">left</code> list.</li>
  <li>The <code class="language-plaintext highlighter-rouge">merge</code> function takes two sorted lists (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) as input and returns a single sorted list.</li>
  <li>If one of the input lists is empty, the function returns the other list as is.</li>
  <li>Otherwise, the function compares the first elements of the two lists and adds the smaller one to the output list.</li>
  <li>The function then recursively calls itself with the remaining elements of the input lists until both input lists are empty.</li>
  <li>Finally, the <code class="language-plaintext highlighter-rouge">merge_sort</code> function merges the two sorted halves of the original list using the <code class="language-plaintext highlighter-rouge">merge</code> function.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The time complexity of merge sort is O(n log n), where n is the number of elements in the input list. This is because the algorithm recursively divides the input list into halves until each half contains only one element, which takes O(log n) time. Then, the algorithm merges the sorted halves back together, which takes O(n) time. Therefore, the total time complexity is O(n log n).</p>

<p>The space complexity of merge sort is O(n), where n is the number of elements in the input list. This is because the algorithm creates temporary lists to store the halves of the input list during the merge process. However, these temporary lists are deallocated after each recursive call, so the overall space complexity is O(n).</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Merge sort is a divide-and-conquer algorithm that sorts an array or list of elements by recursively dividing it into two halves, sorting each half, and then merging the sorted halves back together. It is a highly efficient sorting algorithm with a time complexity of O(n log n), making it suitable for large datasets. Merge sort is widely used in various applications, including sorting large databases, numerical analysis, and parallel computing. Implementation Here is an implementation of merge sort in OCaml: let rec merge_sort = function | [] -&gt; [] | [x] -&gt; [x] | xs -&gt; let rec split left right = function | [] -&gt; (left, right) | x :: xs -&gt; split right (x :: left) xs in let rec merge left right = match left, right with | [], _ -&gt; right | _, [] -&gt; left | x :: xs, y :: ys -&gt; if x &lt; y then x :: merge xs right else y :: merge left ys in let left, right = split [] [] xs in merge (merge_sort left) (merge_sort right) Here is an example of using this implementation to sort a list of integers: let sorted_list = merge_sort [4; 2; 7; 1; 3; 6; 5];; The resulting sorted_list will be [1; 2; 3; 4; 5; 6; 7]. Step-by-step Explanation The merge_sort function takes a list of elements as input. If the list is empty or contains only one element, it is already sorted, so the function returns the list as is. Otherwise, the function recursively divides the list into two halves using the split function. The split function takes two empty lists (left and right) and the original list as input. If the original list is empty, the function returns the two half lists. Otherwise, the function takes the first element of the original list and adds it to the right list, while the rest of the list is recursively split with the right list becoming the new left list. The merge function takes two sorted lists (left and right) as input and returns a single sorted list. If one of the input lists is empty, the function returns the other list as is. Otherwise, the function compares the first elements of the two lists and adds the smaller one to the output list. The function then recursively calls itself with the remaining elements of the input lists until both input lists are empty. Finally, the merge_sort function merges the two sorted halves of the original list using the merge function. Complexity Analysis The time complexity of merge sort is O(n log n), where n is the number of elements in the input list. This is because the algorithm recursively divides the input list into halves until each half contains only one element, which takes O(log n) time. Then, the algorithm merges the sorted halves back together, which takes O(n) time. Therefore, the total time complexity is O(n log n). The space complexity of merge sort is O(n), where n is the number of elements in the input list. This is because the algorithm creates temporary lists to store the halves of the input list during the merge process. However, these temporary lists are deallocated after each recursive call, so the overall space complexity is O(n).]]></summary></entry><entry><title type="html">Heapsort</title><link href="/blog/algorithm/2023/11/20/heapsort.html" rel="alternate" type="text/html" title="Heapsort" /><published>2023-11-20T22:04:00+02:00</published><updated>2023-11-20T22:04:00+02:00</updated><id>/blog/algorithm/2023/11/20/heapsort</id><content type="html" xml:base="/blog/algorithm/2023/11/20/heapsort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Heapsort is a comparison-based sorting algorithm that uses a binary heap data structure. It was first proposed by J. W. J. Williams in 1964. Heapsort is an in-place algorithm, meaning that it sorts the array in place, without needing any additional memory. It has a time complexity of O(n log n), which makes it efficient for large data sets.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of heapsort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">swap</span> <span class="n">arr</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>  
  <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>  
  <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">temp</span>  
   
<span class="k">let</span> <span class="k">rec</span> <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="n">i</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">i</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">in</span>  
  <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">largest</span><span class="p">)</span> <span class="k">then</span>  
    <span class="n">largest</span> <span class="o">:=</span> <span class="n">left</span><span class="p">;</span>  
  <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">largest</span><span class="p">)</span> <span class="k">then</span>  
    <span class="n">largest</span> <span class="o">:=</span> <span class="n">right</span><span class="p">;</span>  
  <span class="k">if</span> <span class="o">!</span><span class="n">largest</span> <span class="o">&lt;&gt;</span> <span class="n">i</span> <span class="k">then</span> <span class="p">(</span>  
    <span class="n">swap</span> <span class="n">arr</span> <span class="n">i</span> <span class="o">!</span><span class="n">largest</span><span class="p">;</span>  
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="o">!</span><span class="n">largest</span>  
  <span class="p">)</span>  
   
<span class="k">let</span> <span class="n">heapsort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>  
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="n">i</span>  
  <span class="k">done</span><span class="p">;</span>  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">1</span> <span class="k">do</span>  
    <span class="n">swap</span> <span class="n">arr</span> <span class="mi">0</span> <span class="n">i</span><span class="p">;</span>  
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">i</span> <span class="mi">0</span>  
  <span class="k">done</span>  
</code></pre></div></div>

<p>Here is an example of how to use the heapsort function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span><span class="mi">4</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">3</span><span class="o">|</span><span class="p">]</span> <span class="k">in</span>  
<span class="n">heapsort</span> <span class="n">arr</span><span class="p">;</span>  
<span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"%d "</span><span class="p">)</span> <span class="n">arr</span>  
</code></pre></div></div>

<p>Output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 2 3 4 7  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Build a max heap from the input data. A binary heap is a complete binary tree where each node is greater than or equal to its children. The largest element is stored at the root of the heap.</li>
  <li>Swap the root node with the last element in the array. Decrease the heap size by 1.</li>
  <li>Call heapify on the root node to restore the heap property.</li>
  <li>Repeat steps 2-3 until the heap size is 1.</li>
</ol>

<p>The heapify function takes three arguments: the array to be sorted, the size of the heap, and the index of the current node. It compares the current node with its left and right children and swaps it with the largest child if necessary. It then recursively calls heapify on the largest child to ensure that the subtree rooted at the current node is also a heap.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of heapsort is O(n log n) in the worst case. Building the heap takes O(n) time, and each call to heapify takes O(log n) time. We call heapify n-1 times in the second loop, so the total time complexity is O(n log n).</p>

<p>Heapsort is an in-place sorting algorithm, so it requires no additional memory beyond the array to be sorted. However, it is not a stable sorting algorithm, meaning that it does not preserve the relative order of equal elements in the input array.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Heapsort is a comparison-based sorting algorithm that uses a binary heap data structure. It was first proposed by J. W. J. Williams in 1964. Heapsort is an in-place algorithm, meaning that it sorts the array in place, without needing any additional memory. It has a time complexity of O(n log n), which makes it efficient for large data sets. Implementation Here is an implementation of heapsort in OCaml: let swap arr i j = let temp = arr.(i) in arr.(i) &lt;- arr.(j); arr.(j) &lt;- temp let rec heapify arr n i = let largest = ref i in let left = 2 * i + 1 in let right = 2 * i + 2 in if left &lt; n &amp;&amp; arr.(left) &gt; arr.(!largest) then largest := left; if right &lt; n &amp;&amp; arr.(right) &gt; arr.(!largest) then largest := right; if !largest &lt;&gt; i then ( swap arr i !largest; heapify arr n !largest ) let heapsort arr = let n = Array.length arr in for i = n / 2 - 1 downto 0 do heapify arr n i done; for i = n - 1 downto 1 do swap arr 0 i; heapify arr i 0 done Here is an example of how to use the heapsort function: let arr = [|4; 2; 7; 1; 3|] in heapsort arr; Array.iter (Printf.printf "%d ") arr Output: 1 2 3 4 7 Step-by-step Explanation Build a max heap from the input data. A binary heap is a complete binary tree where each node is greater than or equal to its children. The largest element is stored at the root of the heap. Swap the root node with the last element in the array. Decrease the heap size by 1. Call heapify on the root node to restore the heap property. Repeat steps 2-3 until the heap size is 1. The heapify function takes three arguments: the array to be sorted, the size of the heap, and the index of the current node. It compares the current node with its left and right children and swaps it with the largest child if necessary. It then recursively calls heapify on the largest child to ensure that the subtree rooted at the current node is also a heap. Complexity Analysis The time complexity of heapsort is O(n log n) in the worst case. Building the heap takes O(n) time, and each call to heapify takes O(log n) time. We call heapify n-1 times in the second loop, so the total time complexity is O(n log n). Heapsort is an in-place sorting algorithm, so it requires no additional memory beyond the array to be sorted. However, it is not a stable sorting algorithm, meaning that it does not preserve the relative order of equal elements in the input array.]]></summary></entry><entry><title type="html">Quicksort</title><link href="/blog/algorithm/2023/11/20/quicksort.html" rel="alternate" type="text/html" title="Quicksort" /><published>2023-11-20T20:46:37+02:00</published><updated>2023-11-20T20:46:37+02:00</updated><id>/blog/algorithm/2023/11/20/quicksort</id><content type="html" xml:base="/blog/algorithm/2023/11/20/quicksort.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Quicksort was developed by British computer scientist Tony Hoare in 1959. It is one of the most widely used sorting algorithms and is commonly used in computer science and engineering applications.</p>

<p>Quicksort is particularly useful when sorting large datasets because it has an average time complexity of O(n log n), which is faster than many other sorting algorithms. It is also an in-place sorting algorithm, meaning that it does not require any additional memory beyond the input array.</p>

<p>Quicksort is used in a variety of applications, including sorting large databases, sorting elements in computer graphics and image processing, and in network routing algorithms. It is also used in many programming languages as a built-in sorting function, such as Python’s <code class="language-plaintext highlighter-rouge">sorted()</code> function and C++’s <code class="language-plaintext highlighter-rouge">std::sort()</code> function.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">quicksort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="n">pivot</span><span class="o">::</span><span class="n">tail</span> <span class="o">-&gt;</span>  
    <span class="k">let</span> <span class="n">lesser</span><span class="o">,</span> <span class="n">greater</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">partition</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">)</span> <span class="n">tail</span> <span class="k">in</span>  
    <span class="n">quicksort</span> <span class="n">lesser</span> <span class="o">@</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">@</span> <span class="n">quicksort</span> <span class="n">greater</span>  
</code></pre></div></div>

<p>This implementation uses a functional programming style and takes advantage of pattern matching to handle the two cases of the input list: the empty list, which is already sorted, and a non-empty list, which is partitioned into two sub-lists based on a pivot element (in this case, the first element of the list).</p>

<p>The <code class="language-plaintext highlighter-rouge">List.partition</code> function is used to split the tail of the input list into two sub-lists: <code class="language-plaintext highlighter-rouge">lesser</code>, which contains all elements that are strictly less than the pivot, and <code class="language-plaintext highlighter-rouge">greater</code>, which contains all elements that are greater than or equal to the pivot. The <code class="language-plaintext highlighter-rouge">@</code> operator is used to concatenate the sorted <code class="language-plaintext highlighter-rouge">lesser</code> sub-list, the pivot element, and the sorted <code class="language-plaintext highlighter-rouge">greater</code> sub-list into a single sorted list.</p>

<p>Here’s an example usage of the <code class="language-plaintext highlighter-rouge">quicksort</code> function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let unsorted = [5; 1; 3; 9; 2]  
let sorted = quicksort unsorted  
</code></pre></div></div>

<p>After running this code, the <code class="language-plaintext highlighter-rouge">sorted</code> variable should contain the list <code class="language-plaintext highlighter-rouge">[1; 2; 3; 5; 9]</code>, which is the sorted version of the <code class="language-plaintext highlighter-rouge">unsorted</code> list.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<p>Here’s a step-by-step explanation of how the quicksort algorithm works:</p>

<ol>
  <li>
    <p>Choose a pivot element from the list. This can be any element, but a common choice is the first or last element in the list.</p>
  </li>
  <li>
    <p>Partition the list into two sub-lists, with one sub-list containing elements less than the pivot and the other sub-list containing elements greater than or equal to the pivot. This can be done by iterating through the list and swapping elements as necessary to ensure that all elements less than the pivot are on one side of the pivot and all elements greater than or equal to the pivot are on the other side.</p>
  </li>
  <li>
    <p>Recursively apply steps 1 and 2 to the sub-lists until the entire list is sorted. This can be done by calling the quicksort function on each sub-list.</p>
  </li>
</ol>

<p>Here’s an example of how this algorithm would sort the list <code class="language-plaintext highlighter-rouge">[5; 1; 3; 9; 2]</code>:</p>

<ol>
  <li>
    <p>Choose the first element, <code class="language-plaintext highlighter-rouge">5</code>, as the pivot.</p>
  </li>
  <li>
    <p>Partition the list into two sub-lists: <code class="language-plaintext highlighter-rouge">[1; 3; 2]</code> and <code class="language-plaintext highlighter-rouge">[9]</code>. All elements less than <code class="language-plaintext highlighter-rouge">5</code> are on the left and all elements greater than or equal to <code class="language-plaintext highlighter-rouge">5</code> are on the right.</p>
  </li>
  <li>
    <p>Recursively apply steps 1 and 2 to each sub-list. For the left sub-list, choose <code class="language-plaintext highlighter-rouge">1</code> as the pivot and partition it into <code class="language-plaintext highlighter-rouge">[ ]</code>, <code class="language-plaintext highlighter-rouge">[1]</code>, and <code class="language-plaintext highlighter-rouge">[3; 2]</code>. For the right sub-list, it is already sorted.</p>
  </li>
  <li>
    <p>Recursively apply steps 1 and 2 to the sub-lists <code class="language-plaintext highlighter-rouge">[1]</code> and <code class="language-plaintext highlighter-rouge">[3; 2]</code>. Both sub-lists are already sorted, so no further partitioning is necessary.</p>
  </li>
  <li>
    <p>Concatenate the sorted sub-lists in the order <code class="language-plaintext highlighter-rouge">[1]</code>, <code class="language-plaintext highlighter-rouge">[2; 3]</code>, <code class="language-plaintext highlighter-rouge">[5]</code>, and <code class="language-plaintext highlighter-rouge">[9]</code> to obtain the sorted list <code class="language-plaintext highlighter-rouge">[1; 2; 3; 5; 9]</code>.</p>
  </li>
</ol>

<p>This example shows how the quicksort algorithm works by recursively dividing the input list into smaller sub-lists, sorting them, and then combining them to obtain the final sorted list.</p>

<h2 id="complexity">Complexity</h2>

<p>The time complexity of quicksort is O(n log n) on average, where n is the number of elements in the input list.</p>

<p>The average case occurs when the pivot element is chosen randomly and is close to the median value of the list. In this case, the list is divided roughly in half with each partition, and the algorithm will make log n recursive calls to sort the entire list. The partitioning step takes linear time, so the total time complexity is O(n log n).</p>

<p>However, in the worst case, quicksort can have a time complexity of O(n^2) if the pivot element is consistently chosen poorly. For example, if the pivot is always chosen as the smallest or largest element in the list, then each partition will only remove one element from the list, and the algorithm will make n recursive calls to sort the entire list. This worst-case scenario is rare in practice, but it can occur in certain edge cases.</p>

<p>In terms of space complexity, quicksort is an in-place sorting algorithm, meaning that it does not require any additional memory beyond the input list. However, the recursive nature of the algorithm means that it has a space complexity of O(log n) due to the call stack used for the recursive calls.</p>

<p>Overall, quicksort is a highly efficient sorting algorithm with a time complexity of O(n log n) on average, making it a popular choice for sorting large datasets.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Selection Sort</title><link href="/blog/algorithm/2023/11/10/shell-sort.html" rel="alternate" type="text/html" title="Selection Sort" /><published>2023-11-10T23:00:00+02:00</published><updated>2023-11-10T23:00:00+02:00</updated><id>/blog/algorithm/2023/11/10/shell-sort</id><content type="html" xml:base="/blog/algorithm/2023/11/10/shell-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Shell sort is an efficient sorting algorithm that is a variation of insertion sort. It was invented by Donald Shell in 1959. The algorithm works by sorting elements that are far apart from each other and then gradually reducing the gap between them. This makes the algorithm faster than insertion sort for larger lists.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of Shell sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">shell_sort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">gap</span> <span class="o">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span>  
  <span class="k">while</span> <span class="o">!</span><span class="n">gap</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">do</span>  
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="o">!</span><span class="n">gap</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>  
      <span class="k">let</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>  
      <span class="k">let</span> <span class="n">j</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">i</span> <span class="k">in</span>  
      <span class="k">while</span> <span class="o">!</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="o">!</span><span class="n">gap</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">j</span> <span class="o">-</span> <span class="o">!</span><span class="n">gap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">temp</span> <span class="k">do</span>  
        <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">j</span> <span class="o">-</span> <span class="o">!</span><span class="n">gap</span><span class="p">);</span>  
        <span class="n">j</span> <span class="o">:=</span> <span class="o">!</span><span class="n">j</span> <span class="o">-</span> <span class="o">!</span><span class="n">gap</span>  
      <span class="k">done</span><span class="p">;</span>  
      <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">temp</span>  
    <span class="k">done</span><span class="p">;</span>  
    <span class="n">gap</span> <span class="o">:=</span> <span class="o">!</span><span class="n">gap</span> <span class="o">/</span> <span class="mi">2</span>  
  <span class="k">done</span><span class="p">;</span>  
  <span class="n">arr</span>  
</code></pre></div></div>

<p>To use this function, simply pass in an array of elements to sort:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">8</span><span class="p">;</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">2</span> <span class="o">|</span><span class="p">]</span>  
<span class="k">let</span> <span class="n">sorted_arr</span> <span class="o">=</span> <span class="n">shell_sort</span> <span class="n">arr</span>  
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">sorted_arr</code> variable will contain the sorted array.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Start by dividing the list into sublists of equal intervals. The interval is called the gap.</li>
  <li>Sort each sublist using insertion sort.</li>
  <li>Reduce the gap by half and repeat step 2 until the gap is 1.</li>
</ol>

<p>For example, let’s say we have the following list of integers: <code class="language-plaintext highlighter-rouge">[5, 3, 8, 4, 2]</code>. We’ll use a gap of 2 for the first pass.</p>

<ol>
  <li>Divide the list into sublists with a gap of 2: <code class="language-plaintext highlighter-rouge">[5, 8, 2]</code> and <code class="language-plaintext highlighter-rouge">[3, 4]</code>.</li>
  <li>Sort each sublist using insertion sort. The first sublist becomes <code class="language-plaintext highlighter-rouge">[2, 5, 8]</code> and the second sublist stays the same: <code class="language-plaintext highlighter-rouge">[3, 4]</code>.</li>
  <li>Reduce the gap to 1 and sort the entire list using insertion sort. The sorted list is <code class="language-plaintext highlighter-rouge">[2, 3, 4, 5, 8]</code>.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Shell sort depends on the gap sequence used. The worst-case time complexity is O(n^2), which occurs when the gap sequence is 1, making the algorithm equivalent to insertion sort. However, the average-case time complexity is O(n log n), which is faster than insertion sort for larger lists.</p>

<p>The space complexity of Shell sort is O(1) because it sorts the list in place.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Shell sort is an efficient sorting algorithm that is a variation of insertion sort. It was invented by Donald Shell in 1959. The algorithm works by sorting elements that are far apart from each other and then gradually reducing the gap between them. This makes the algorithm faster than insertion sort for larger lists. Implementation Here is an implementation of Shell sort in OCaml: let shell_sort arr = let n = Array.length arr in let gap = ref (n / 2) in while !gap &gt; 0 do for i = !gap to n - 1 do let temp = arr.(i) in let j = ref i in while !j &gt;= !gap &amp;&amp; arr.(!j - !gap) &gt; temp do arr.(!j) &lt;- arr.(!j - !gap); j := !j - !gap done; arr.(!j) &lt;- temp done; gap := !gap / 2 done; arr To use this function, simply pass in an array of elements to sort: let arr = [| 5; 3; 8; 4; 2 |] let sorted_arr = shell_sort arr The sorted_arr variable will contain the sorted array. Step-by-step Explanation Start by dividing the list into sublists of equal intervals. The interval is called the gap. Sort each sublist using insertion sort. Reduce the gap by half and repeat step 2 until the gap is 1. For example, let’s say we have the following list of integers: [5, 3, 8, 4, 2]. We’ll use a gap of 2 for the first pass. Divide the list into sublists with a gap of 2: [5, 8, 2] and [3, 4]. Sort each sublist using insertion sort. The first sublist becomes [2, 5, 8] and the second sublist stays the same: [3, 4]. Reduce the gap to 1 and sort the entire list using insertion sort. The sorted list is [2, 3, 4, 5, 8]. Complexity Analysis The time complexity of Shell sort depends on the gap sequence used. The worst-case time complexity is O(n^2), which occurs when the gap sequence is 1, making the algorithm equivalent to insertion sort. However, the average-case time complexity is O(n log n), which is faster than insertion sort for larger lists. The space complexity of Shell sort is O(1) because it sorts the list in place.]]></summary></entry><entry><title type="html">Counting Sort</title><link href="/blog/algorithm/2023/11/10/counting-sort.html" rel="alternate" type="text/html" title="Counting Sort" /><published>2023-11-10T20:00:00+02:00</published><updated>2023-11-10T20:00:00+02:00</updated><id>/blog/algorithm/2023/11/10/counting-sort</id><content type="html" xml:base="/blog/algorithm/2023/11/10/counting-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Counting sort is an efficient sorting algorithm that can be used to sort elements in a range of integers. It is a non-comparison based sorting algorithm that works by counting the number of occurrences of each element in the array and then using this information to determine the position of each element in the sorted output array.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of counting sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">counting_sort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">max_val</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">max</span> <span class="n">arr</span> <span class="mi">0</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">count_arr</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="p">(</span><span class="n">max_val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="k">in</span>  
  <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">count_arr</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">count_arr</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">arr</span><span class="p">;</span>  
  <span class="k">let</span> <span class="n">index_arr</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="p">(</span><span class="n">max_val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">fill_index_arr</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>  
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_val</span> <span class="k">then</span>  
      <span class="k">begin</span>  
        <span class="n">index_arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">j</span><span class="p">;</span>  
        <span class="n">fill_index_arr</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">count_arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>  
      <span class="k">end</span>  
  <span class="k">in</span>  
  <span class="n">fill_index_arr</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span>  
  <span class="k">let</span> <span class="n">sorted_arr</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="p">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span><span class="p">)</span> <span class="mi">0</span> <span class="k">in</span>  
  <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">sorted_arr</span><span class="o">.</span><span class="p">(</span><span class="n">index_arr</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">&lt;-</span> <span class="n">x</span><span class="p">;</span> <span class="n">index_arr</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">index_arr</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">arr</span><span class="p">;</span>  
  <span class="n">sorted_arr</span>  
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">arr</code> is the input array to be sorted. The function <code class="language-plaintext highlighter-rouge">counting_sort</code> first finds the maximum value in the input array and creates a new array <code class="language-plaintext highlighter-rouge">count_arr</code> to count the number of occurrences of each element in the input array. It then creates another array <code class="language-plaintext highlighter-rouge">index_arr</code> to store the index of each element in the sorted output array. The function <code class="language-plaintext highlighter-rouge">fill_index_arr</code> is a helper function that fills in the <code class="language-plaintext highlighter-rouge">index_arr</code> array based on the counts in <code class="language-plaintext highlighter-rouge">count_arr</code>. Finally, the function creates a new array <code class="language-plaintext highlighter-rouge">sorted_arr</code> and fills it in by iterating over the input array and using the <code class="language-plaintext highlighter-rouge">index_arr</code> array to determine the position of each element in the sorted output array.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Find the maximum value in the input array.</li>
  <li>Create a new array <code class="language-plaintext highlighter-rouge">count_arr</code> of length <code class="language-plaintext highlighter-rouge">max_val + 1</code> and initialize all elements to 0.</li>
  <li>Iterate over the input array and increment the count of each element in <code class="language-plaintext highlighter-rouge">count_arr</code>.</li>
  <li>Create a new array <code class="language-plaintext highlighter-rouge">index_arr</code> of length <code class="language-plaintext highlighter-rouge">max_val + 1</code> and initialize all elements to 0.</li>
  <li>Define a helper function <code class="language-plaintext highlighter-rouge">fill_index_arr</code> that fills in the <code class="language-plaintext highlighter-rouge">index_arr</code> array based on the counts in <code class="language-plaintext highlighter-rouge">count_arr</code>. The function takes two arguments: <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code>, where <code class="language-plaintext highlighter-rouge">i</code> is the current index in <code class="language-plaintext highlighter-rouge">count_arr</code> and <code class="language-plaintext highlighter-rouge">j</code> is the current index in <code class="language-plaintext highlighter-rouge">index_arr</code>.</li>
  <li>Call the <code class="language-plaintext highlighter-rouge">fill_index_arr</code> function with initial arguments <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">0</code>.</li>
  <li>Create a new array <code class="language-plaintext highlighter-rouge">sorted_arr</code> of length <code class="language-plaintext highlighter-rouge">n</code>, where <code class="language-plaintext highlighter-rouge">n</code> is the length of the input array.</li>
  <li>Iterate over the input array and use the <code class="language-plaintext highlighter-rouge">index_arr</code> array to determine the position of each element in the sorted output array. Store each element in the corresponding position in <code class="language-plaintext highlighter-rouge">sorted_arr</code>.</li>
  <li>Return <code class="language-plaintext highlighter-rouge">sorted_arr</code>.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of counting sort is O(n + k), where n is the length of the input array and k is the range of the input integers. The space complexity is also O(n + k).</p>

<p>The algorithm iterates over the input array twice: once to count the occurrences of each element and once to fill in the sorted output array. The time complexity of these two iterations is O(n). The algorithm also creates two additional arrays: <code class="language-plaintext highlighter-rouge">count_arr</code> and <code class="language-plaintext highlighter-rouge">index_arr</code>, each of length k. Therefore, the space complexity of the algorithm is O(n + k).</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Counting sort is an efficient sorting algorithm that can be used to sort elements in a range of integers. It is a non-comparison based sorting algorithm that works by counting the number of occurrences of each element in the array and then using this information to determine the position of each element in the sorted output array. Implementation Here is an implementation of counting sort in OCaml: let counting_sort arr = let max_val = Array.fold_left max arr 0 in let count_arr = Array.make (max_val + 1) 0 in Array.iter (fun x -&gt; count_arr.(x) &lt;- count_arr.(x) + 1) arr; let index_arr = Array.make (max_val + 1) 0 in let rec fill_index_arr i j = if i &lt;= max_val then begin index_arr.(i) &lt;- j; fill_index_arr (i + 1) (j + count_arr.(i)) end in fill_index_arr 0 0; let sorted_arr = Array.make (Array.length arr) 0 in Array.iter (fun x -&gt; sorted_arr.(index_arr.(x)) &lt;- x; index_arr.(x) &lt;- index_arr.(x) + 1) arr; sorted_arr Here, arr is the input array to be sorted. The function counting_sort first finds the maximum value in the input array and creates a new array count_arr to count the number of occurrences of each element in the input array. It then creates another array index_arr to store the index of each element in the sorted output array. The function fill_index_arr is a helper function that fills in the index_arr array based on the counts in count_arr. Finally, the function creates a new array sorted_arr and fills it in by iterating over the input array and using the index_arr array to determine the position of each element in the sorted output array. Step-by-step Explanation Find the maximum value in the input array. Create a new array count_arr of length max_val + 1 and initialize all elements to 0. Iterate over the input array and increment the count of each element in count_arr. Create a new array index_arr of length max_val + 1 and initialize all elements to 0. Define a helper function fill_index_arr that fills in the index_arr array based on the counts in count_arr. The function takes two arguments: i and j, where i is the current index in count_arr and j is the current index in index_arr. Call the fill_index_arr function with initial arguments 0 and 0. Create a new array sorted_arr of length n, where n is the length of the input array. Iterate over the input array and use the index_arr array to determine the position of each element in the sorted output array. Store each element in the corresponding position in sorted_arr. Return sorted_arr. Complexity Analysis The time complexity of counting sort is O(n + k), where n is the length of the input array and k is the range of the input integers. The space complexity is also O(n + k). The algorithm iterates over the input array twice: once to count the occurrences of each element and once to fill in the sorted output array. The time complexity of these two iterations is O(n). The algorithm also creates two additional arrays: count_arr and index_arr, each of length k. Therefore, the space complexity of the algorithm is O(n + k).]]></summary></entry><entry><title type="html">Selection Sort</title><link href="/blog/algorithm/2023/11/10/selection-sort.html" rel="alternate" type="text/html" title="Selection Sort" /><published>2023-11-10T19:00:00+02:00</published><updated>2023-11-10T19:00:00+02:00</updated><id>/blog/algorithm/2023/11/10/selection-sort</id><content type="html" xml:base="/blog/algorithm/2023/11/10/selection-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Selection sort is a simple sorting algorithm that works by repeatedly finding the minimum element from an unsorted list and putting it at the beginning. The algorithm is not very efficient for large lists, but it has the advantage of being simple to understand and implement.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of selection sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">find_min</span> <span class="n">i</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">if</span> <span class="n">i</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">then</span> <span class="o">-</span><span class="mi">1</span>  
  <span class="k">else</span>  
    <span class="k">let</span> <span class="n">min_idx</span> <span class="o">=</span> <span class="n">find_min</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">arr</span> <span class="k">in</span>  
    <span class="k">if</span> <span class="n">min_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">min_idx</span><span class="p">)</span> <span class="k">then</span> <span class="n">i</span> <span class="k">else</span> <span class="n">min_idx</span>  
   
<span class="k">let</span> <span class="n">selection_sort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>  
    <span class="k">let</span> <span class="n">min_idx</span> <span class="o">=</span> <span class="n">find_min</span> <span class="n">i</span> <span class="n">arr</span> <span class="k">in</span>  
    <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>  
    <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">min_idx</span><span class="p">);</span>  
    <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">min_idx</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">tmp</span>  
  <span class="k">done</span>  
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">find_min</code> is a helper function that finds the index of the minimum element in the array <code class="language-plaintext highlighter-rouge">arr</code> starting from index <code class="language-plaintext highlighter-rouge">i</code>. It returns <code class="language-plaintext highlighter-rouge">-1</code> if <code class="language-plaintext highlighter-rouge">i</code> is already at the end of the array. <code class="language-plaintext highlighter-rouge">selection_sort</code> uses <code class="language-plaintext highlighter-rouge">find_min</code> to find the minimum element in the unsorted portion of the array and swaps it with the first element in the unsorted portion. This process is repeated until the entire array is sorted.</p>

<p>Here is an example of using <code class="language-plaintext highlighter-rouge">selection_sort</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span><span class="mi">5</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">9</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">6</span><span class="o">|</span><span class="p">]</span>  
<span class="n">selection_sort</span> <span class="n">arr</span>  
<span class="c">(* arr is now [|2; 3; 5; 6; 9|] *)</span>  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>We start with an unsorted array <code class="language-plaintext highlighter-rouge">arr</code>.</li>
  <li>We iterate over the array from index <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n-1</code>, where <code class="language-plaintext highlighter-rouge">n</code> is the length of the array.</li>
  <li>For each iteration, we call <code class="language-plaintext highlighter-rouge">find_min</code> to find the index of the minimum element in the unsorted portion of the array starting from index <code class="language-plaintext highlighter-rouge">i</code>.</li>
  <li>We swap the element at index <code class="language-plaintext highlighter-rouge">i</code> with the minimum element found in step 3.</li>
  <li>We repeat steps 3-4 until the entire array is sorted.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of selection sort is O(n^2), where n is the length of the array. This is because we have to iterate over the entire array n times, and for each iteration, we have to find the minimum element in the unsorted portion of the array, which takes O(n) time. The space complexity of selection sort is O(1), because we only need to store a few variables to keep track of the indices and the temporary value during the swapping process.</p>

<p>Selection sort is not very efficient for large arrays, but it has the advantage of being simple to implement and understand. It can also be useful in situations where memory is limited, since it only requires a constant amount of extra memory.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Selection sort is a simple sorting algorithm that works by repeatedly finding the minimum element from an unsorted list and putting it at the beginning. The algorithm is not very efficient for large lists, but it has the advantage of being simple to understand and implement. Implementation Here is an implementation of selection sort in OCaml: let rec find_min i arr = if i = Array.length arr then -1 else let min_idx = find_min (i+1) arr in if min_idx = -1 || arr.(i) &lt; arr.(min_idx) then i else min_idx let selection_sort arr = for i = 0 to Array.length arr - 1 do let min_idx = find_min i arr in let tmp = arr.(i) in arr.(i) &lt;- arr.(min_idx); arr.(min_idx) &lt;- tmp done Here, find_min is a helper function that finds the index of the minimum element in the array arr starting from index i. It returns -1 if i is already at the end of the array. selection_sort uses find_min to find the minimum element in the unsorted portion of the array and swaps it with the first element in the unsorted portion. This process is repeated until the entire array is sorted. Here is an example of using selection_sort: let arr = [|5; 2; 9; 3; 6|] selection_sort arr (* arr is now [|2; 3; 5; 6; 9|] *) Step-by-step Explanation We start with an unsorted array arr. We iterate over the array from index 0 to n-1, where n is the length of the array. For each iteration, we call find_min to find the index of the minimum element in the unsorted portion of the array starting from index i. We swap the element at index i with the minimum element found in step 3. We repeat steps 3-4 until the entire array is sorted. Complexity Analysis The time complexity of selection sort is O(n^2), where n is the length of the array. This is because we have to iterate over the entire array n times, and for each iteration, we have to find the minimum element in the unsorted portion of the array, which takes O(n) time. The space complexity of selection sort is O(1), because we only need to store a few variables to keep track of the indices and the temporary value during the swapping process. Selection sort is not very efficient for large arrays, but it has the advantage of being simple to implement and understand. It can also be useful in situations where memory is limited, since it only requires a constant amount of extra memory.]]></summary></entry><entry><title type="html">Bubble Sort</title><link href="/blog/algorithm/2023/11/10/bubble-sort.html" rel="alternate" type="text/html" title="Bubble Sort" /><published>2023-11-10T18:00:00+02:00</published><updated>2023-11-10T18:00:00+02:00</updated><id>/blog/algorithm/2023/11/10/bubble-sort</id><content type="html" xml:base="/blog/algorithm/2023/11/10/bubble-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Bubble Sort is a simple sorting algorithm that repeatedly swaps adjacent elements if they are in the wrong order. It is named as bubble sort because the smaller elements bubble up to the top of the list as the algorithm iterates through the list. Bubble Sort is not an efficient algorithm for large lists and is generally used for educational purposes.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of Bubble Sort in OCaml:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let bubble_sort arr =  
  let n = Array.length arr in  
  for i = 0 to n - 2 do  
    for j = 0 to n - i - 2 do  
      if arr.(j) &gt; arr.(j+1) then  
        let temp = arr.(j) in  
        arr.(j) &lt;- arr.(j+1);  
        arr.(j+1) &lt;- temp  
    done  
  done;;  
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">arr</code> is the array to be sorted. The function <code class="language-plaintext highlighter-rouge">bubble_sort</code> uses two nested loops to iterate through the array and compare adjacent elements. If the elements are in the wrong order, they are swapped. The outer loop iterates from 0 to n-2, while the inner loop iterates from 0 to n-i-2. This is because the largest element in the list will already be in its correct position after each iteration of the outer loop.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Start with an unsorted array of n elements.</li>
  <li>Compare the first two elements. If the first element is greater than the second element, swap them.</li>
  <li>Move to the next pair of adjacent elements and repeat step 2 until the end of the array is reached.</li>
  <li>Repeat steps 2 and 3 for each pair of adjacent elements until the end of the array is reached.</li>
  <li>After each iteration, the largest element will be in its correct position at the end of the array.</li>
  <li>Repeat steps 2-5 n-1 times to sort the entire array.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Bubble Sort is O(n^2), where n is the number of elements in the array. This is because the algorithm uses two nested loops to iterate through the array and compare adjacent elements. In the worst case scenario, where the array is in reverse order, the algorithm will need to make n*(n-1)/2 comparisons and swaps. The space complexity of Bubble Sort is O(1), as the algorithm only requires a constant amount of additional memory to store temporary variables for swapping elements.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Bubble Sort is a simple sorting algorithm that repeatedly swaps adjacent elements if they are in the wrong order. It is named as bubble sort because the smaller elements bubble up to the top of the list as the algorithm iterates through the list. Bubble Sort is not an efficient algorithm for large lists and is generally used for educational purposes. Implementation Here is an implementation of Bubble Sort in OCaml: let bubble_sort arr = let n = Array.length arr in for i = 0 to n - 2 do for j = 0 to n - i - 2 do if arr.(j) &gt; arr.(j+1) then let temp = arr.(j) in arr.(j) &lt;- arr.(j+1); arr.(j+1) &lt;- temp done done;; Here, arr is the array to be sorted. The function bubble_sort uses two nested loops to iterate through the array and compare adjacent elements. If the elements are in the wrong order, they are swapped. The outer loop iterates from 0 to n-2, while the inner loop iterates from 0 to n-i-2. This is because the largest element in the list will already be in its correct position after each iteration of the outer loop. Step-by-step Explanation Start with an unsorted array of n elements. Compare the first two elements. If the first element is greater than the second element, swap them. Move to the next pair of adjacent elements and repeat step 2 until the end of the array is reached. Repeat steps 2 and 3 for each pair of adjacent elements until the end of the array is reached. After each iteration, the largest element will be in its correct position at the end of the array. Repeat steps 2-5 n-1 times to sort the entire array. Complexity Analysis The time complexity of Bubble Sort is O(n^2), where n is the number of elements in the array. This is because the algorithm uses two nested loops to iterate through the array and compare adjacent elements. In the worst case scenario, where the array is in reverse order, the algorithm will need to make n*(n-1)/2 comparisons and swaps. The space complexity of Bubble Sort is O(1), as the algorithm only requires a constant amount of additional memory to store temporary variables for swapping elements.]]></summary></entry><entry><title type="html">Bucket Sort</title><link href="/blog/algorithm/2023/11/10/bucket-sort.html" rel="alternate" type="text/html" title="Bucket Sort" /><published>2023-11-10T11:00:00+02:00</published><updated>2023-11-10T11:00:00+02:00</updated><id>/blog/algorithm/2023/11/10/bucket-sort</id><content type="html" xml:base="/blog/algorithm/2023/11/10/bucket-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Bucket sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm or by recursively applying the bucket sorting algorithm. Bucket sort is useful when the input is uniformly distributed over a range. It is commonly used in computer graphics, computational biology, and data mining.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of bucket sort in OCaml:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let bucket_sort arr =  
  let n = Array.length arr in  
  let buckets = Array.make n [] in  
  for i = 0 to n - 1 do  
    let bucket_index = int_of_float (arr.(i) *. (float_of_int n)) in  
    buckets.(bucket_index) &lt;- arr.(i) :: buckets.(bucket_index)  
  done;  
  let sorted = ref [] in  
  for i = 0 to n - 1 do  
    buckets.(i) &lt;- List.sort compare buckets.(i);  
    sorted := !sorted @ buckets.(i)  
  done;  
  Array.of_list !sorted  
</code></pre></div></div>

<p>This implementation takes an array of floating-point numbers as input and returns a sorted array.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>The input array is first traversed to determine the number of buckets required. This is done by taking the length of the array and creating an empty bucket for each index.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let n = Array.length arr in  
let buckets = Array.make n [] in  
</code></pre></div>    </div>
  </li>
  <li>The elements of the array are then distributed into the buckets. This is done by iterating over the array and calculating the index of the bucket for each element. The index is calculated by multiplying the element by the number of buckets and taking the integer part of the result.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i = 0 to n - 1 do  
  let bucket_index = int_of_float (arr.(i) *. (float_of_int n)) in  
  buckets.(bucket_index) &lt;- arr.(i) :: buckets.(bucket_index)  
done;  
</code></pre></div>    </div>
  </li>
  <li>Each bucket is then sorted individually. This is done using the OCaml <code class="language-plaintext highlighter-rouge">List.sort</code> function, which sorts a list in ascending order using the <code class="language-plaintext highlighter-rouge">compare</code> function.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i = 0 to n - 1 do  
  buckets.(i) &lt;- List.sort compare buckets.(i);  
done;  
</code></pre></div>    </div>
  </li>
  <li>Finally, the sorted elements are concatenated to form the final sorted array.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let sorted = ref [] in  
for i = 0 to n - 1 do  
  sorted := !sorted @ buckets.(i)  
done;  
Array.of_list !sorted  
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of bucket sort depends on the sorting algorithm used to sort the individual buckets. In the worst case, if each bucket contains all the elements of the input array, the time complexity of bucket sort is O(n^2), where n is the number of elements in the input array. However, if the input is uniformly distributed over a range, the time complexity can be improved to O(n) by using a linear-time sorting algorithm like counting sort or radix sort to sort the individual buckets.</p>

<p>The space complexity of bucket sort is O(n), where n is the number of elements in the input array. This is because we need to create a bucket for each element in the input array. However, if the input is uniformly distributed over a range, the space complexity can be improved to O(k), where k is the number of buckets required, which is much smaller than n.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Bucket sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm or by recursively applying the bucket sorting algorithm. Bucket sort is useful when the input is uniformly distributed over a range. It is commonly used in computer graphics, computational biology, and data mining. Implementation Here is an implementation of bucket sort in OCaml: let bucket_sort arr = let n = Array.length arr in let buckets = Array.make n [] in for i = 0 to n - 1 do let bucket_index = int_of_float (arr.(i) *. (float_of_int n)) in buckets.(bucket_index) &lt;- arr.(i) :: buckets.(bucket_index) done; let sorted = ref [] in for i = 0 to n - 1 do buckets.(i) &lt;- List.sort compare buckets.(i); sorted := !sorted @ buckets.(i) done; Array.of_list !sorted This implementation takes an array of floating-point numbers as input and returns a sorted array. Step-by-step Explanation The input array is first traversed to determine the number of buckets required. This is done by taking the length of the array and creating an empty bucket for each index. let n = Array.length arr in let buckets = Array.make n [] in The elements of the array are then distributed into the buckets. This is done by iterating over the array and calculating the index of the bucket for each element. The index is calculated by multiplying the element by the number of buckets and taking the integer part of the result. for i = 0 to n - 1 do let bucket_index = int_of_float (arr.(i) *. (float_of_int n)) in buckets.(bucket_index) &lt;- arr.(i) :: buckets.(bucket_index) done; Each bucket is then sorted individually. This is done using the OCaml List.sort function, which sorts a list in ascending order using the compare function. for i = 0 to n - 1 do buckets.(i) &lt;- List.sort compare buckets.(i); done; Finally, the sorted elements are concatenated to form the final sorted array. let sorted = ref [] in for i = 0 to n - 1 do sorted := !sorted @ buckets.(i) done; Array.of_list !sorted Complexity Analysis The time complexity of bucket sort depends on the sorting algorithm used to sort the individual buckets. In the worst case, if each bucket contains all the elements of the input array, the time complexity of bucket sort is O(n^2), where n is the number of elements in the input array. However, if the input is uniformly distributed over a range, the time complexity can be improved to O(n) by using a linear-time sorting algorithm like counting sort or radix sort to sort the individual buckets. The space complexity of bucket sort is O(n), where n is the number of elements in the input array. This is because we need to create a bucket for each element in the input array. However, if the input is uniformly distributed over a range, the space complexity can be improved to O(k), where k is the number of buckets required, which is much smaller than n.]]></summary></entry></feed>
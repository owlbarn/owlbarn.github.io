<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-11-20T21:26:35+02:00</updated><id>/feed.xml</id><title type="html">Your awesome title</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Quicksort</title><link href="/algorithm/2023/11/20/quicksort.html" rel="alternate" type="text/html" title="Quicksort" /><published>2023-11-20T20:46:37+02:00</published><updated>2023-11-20T20:46:37+02:00</updated><id>/algorithm/2023/11/20/quicksort</id><content type="html" xml:base="/algorithm/2023/11/20/quicksort.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Quicksort was developed by British computer scientist Tony Hoare in 1959. It is one of the most widely used sorting algorithms and is commonly used in computer science and engineering applications.</p>

<p>Quicksort is particularly useful when sorting large datasets because it has an average time complexity of O(n log n), which is faster than many other sorting algorithms. It is also an in-place sorting algorithm, meaning that it does not require any additional memory beyond the input array.</p>

<p>Quicksort is used in a variety of applications, including sorting large databases, sorting elements in computer graphics and image processing, and in network routing algorithms. It is also used in many programming languages as a built-in sorting function, such as Python’s <code class="language-plaintext highlighter-rouge">sorted()</code> function and C++’s <code class="language-plaintext highlighter-rouge">std::sort()</code> function.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let rec quicksort = function  
  | [] -&gt; []  
  | pivot::tail -&gt;  
    let lesser, greater = List.partition (fun x -&gt; x &lt; pivot) tail in  
    quicksort lesser @ [pivot] @ quicksort greater  
</code></pre></div></div>

<p>This implementation uses a functional programming style and takes advantage of pattern matching to handle the two cases of the input list: the empty list, which is already sorted, and a non-empty list, which is partitioned into two sub-lists based on a pivot element (in this case, the first element of the list).</p>

<p>The <code class="language-plaintext highlighter-rouge">List.partition</code> function is used to split the tail of the input list into two sub-lists: <code class="language-plaintext highlighter-rouge">lesser</code>, which contains all elements that are strictly less than the pivot, and <code class="language-plaintext highlighter-rouge">greater</code>, which contains all elements that are greater than or equal to the pivot. The <code class="language-plaintext highlighter-rouge">@</code> operator is used to concatenate the sorted <code class="language-plaintext highlighter-rouge">lesser</code> sub-list, the pivot element, and the sorted <code class="language-plaintext highlighter-rouge">greater</code> sub-list into a single sorted list.</p>

<p>Here’s an example usage of the <code class="language-plaintext highlighter-rouge">quicksort</code> function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let unsorted = [5; 1; 3; 9; 2]  
let sorted = quicksort unsorted  
</code></pre></div></div>

<p>After running this code, the <code class="language-plaintext highlighter-rouge">sorted</code> variable should contain the list <code class="language-plaintext highlighter-rouge">[1; 2; 3; 5; 9]</code>, which is the sorted version of the <code class="language-plaintext highlighter-rouge">unsorted</code> list.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<p>Here’s a step-by-step explanation of how the quicksort algorithm works:</p>

<ol>
  <li>
    <p>Choose a pivot element from the list. This can be any element, but a common choice is the first or last element in the list.</p>
  </li>
  <li>
    <p>Partition the list into two sub-lists, with one sub-list containing elements less than the pivot and the other sub-list containing elements greater than or equal to the pivot. This can be done by iterating through the list and swapping elements as necessary to ensure that all elements less than the pivot are on one side of the pivot and all elements greater than or equal to the pivot are on the other side.</p>
  </li>
  <li>
    <p>Recursively apply steps 1 and 2 to the sub-lists until the entire list is sorted. This can be done by calling the quicksort function on each sub-list.</p>
  </li>
</ol>

<p>Here’s an example of how this algorithm would sort the list <code class="language-plaintext highlighter-rouge">[5; 1; 3; 9; 2]</code>:</p>

<ol>
  <li>
    <p>Choose the first element, <code class="language-plaintext highlighter-rouge">5</code>, as the pivot.</p>
  </li>
  <li>
    <p>Partition the list into two sub-lists: <code class="language-plaintext highlighter-rouge">[1; 3; 2]</code> and <code class="language-plaintext highlighter-rouge">[9]</code>. All elements less than <code class="language-plaintext highlighter-rouge">5</code> are on the left and all elements greater than or equal to <code class="language-plaintext highlighter-rouge">5</code> are on the right.</p>
  </li>
  <li>
    <p>Recursively apply steps 1 and 2 to each sub-list. For the left sub-list, choose <code class="language-plaintext highlighter-rouge">1</code> as the pivot and partition it into <code class="language-plaintext highlighter-rouge">[ ]</code>, <code class="language-plaintext highlighter-rouge">[1]</code>, and <code class="language-plaintext highlighter-rouge">[3; 2]</code>. For the right sub-list, it is already sorted.</p>
  </li>
  <li>
    <p>Recursively apply steps 1 and 2 to the sub-lists <code class="language-plaintext highlighter-rouge">[1]</code> and <code class="language-plaintext highlighter-rouge">[3; 2]</code>. Both sub-lists are already sorted, so no further partitioning is necessary.</p>
  </li>
  <li>
    <p>Concatenate the sorted sub-lists in the order <code class="language-plaintext highlighter-rouge">[1]</code>, <code class="language-plaintext highlighter-rouge">[2; 3]</code>, <code class="language-plaintext highlighter-rouge">[5]</code>, and <code class="language-plaintext highlighter-rouge">[9]</code> to obtain the sorted list <code class="language-plaintext highlighter-rouge">[1; 2; 3; 5; 9]</code>.</p>
  </li>
</ol>

<p>This example shows how the quicksort algorithm works by recursively dividing the input list into smaller sub-lists, sorting them, and then combining them to obtain the final sorted list.</p>

<h2 id="complexity">Complexity</h2>

<p>The time complexity of quicksort is O(n log n) on average, where n is the number of elements in the input list.</p>

<p>The average case occurs when the pivot element is chosen randomly and is close to the median value of the list. In this case, the list is divided roughly in half with each partition, and the algorithm will make log n recursive calls to sort the entire list. The partitioning step takes linear time, so the total time complexity is O(n log n).</p>

<p>However, in the worst case, quicksort can have a time complexity of O(n^2) if the pivot element is consistently chosen poorly. For example, if the pivot is always chosen as the smallest or largest element in the list, then each partition will only remove one element from the list, and the algorithm will make n recursive calls to sort the entire list. This worst-case scenario is rare in practice, but it can occur in certain edge cases.</p>

<p>In terms of space complexity, quicksort is an in-place sorting algorithm, meaning that it does not require any additional memory beyond the input list. However, the recursive nature of the algorithm means that it has a space complexity of O(log n) due to the call stack used for the recursive calls.</p>

<p>Overall, quicksort is a highly efficient sorting algorithm with a time complexity of O(n log n) on average, making it a popular choice for sorting large datasets.</p>]]></content><author><name></name></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>
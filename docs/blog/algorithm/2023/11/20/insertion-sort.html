<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Insertion Sort | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Insertion Sort" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high. Implementation Here is an implementation of insertion sort in OCaml: let rec insertion_sort = function | [] -&gt; [] | x :: xs -&gt; insert x (insertion_sort xs) and insert x = function | [] -&gt; [x] | y :: ys -&gt; if x &lt; y then x :: y :: ys else y :: insert x ys This implementation uses a recursive function to sort the list. The insertion_sort function takes a list as input and returns a sorted list. The insert function takes an element x and a sorted list as input and returns a new sorted list with x inserted in the correct position. Step-by-step Explanation The insertion_sort function is called with a list as input. If the list is empty, an empty list is returned. Otherwise, the first element x is removed from the list and the insert function is called with x and the sorted list returned by a recursive call to insertion_sort. The insert function takes x and a sorted list as input. If the list is empty, a list with x as the only element is returned. Otherwise, the first element y is removed from the list and the insert function is called recursively with x and the remaining list ys. If x is less than y, a new list with x and y followed by ys is returned. Otherwise, a new list with y followed by the result of calling insert with x and ys is returned. The sorted list returned by insert is returned by insertion_sort. Complexity Analysis The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory." />
<meta property="og:description" content="Introduction Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high. Implementation Here is an implementation of insertion sort in OCaml: let rec insertion_sort = function | [] -&gt; [] | x :: xs -&gt; insert x (insertion_sort xs) and insert x = function | [] -&gt; [x] | y :: ys -&gt; if x &lt; y then x :: y :: ys else y :: insert x ys This implementation uses a recursive function to sort the list. The insertion_sort function takes a list as input and returns a sorted list. The insert function takes an element x and a sorted list as input and returns a new sorted list with x inserted in the correct position. Step-by-step Explanation The insertion_sort function is called with a list as input. If the list is empty, an empty list is returned. Otherwise, the first element x is removed from the list and the insert function is called with x and the sorted list returned by a recursive call to insertion_sort. The insert function takes x and a sorted list as input. If the list is empty, a list with x as the only element is returned. Otherwise, the first element y is removed from the list and the insert function is called recursively with x and the remaining list ys. If x is less than y, a new list with x and y followed by ys is returned. Otherwise, a new list with y followed by the result of calling insert with x and ys is returned. The sorted list returned by insert is returned by insertion_sort. Complexity Analysis The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory." />
<link rel="canonical" href="/blog/algorithm/2023/11/20/insertion-sort.html" />
<meta property="og:url" content="/blog/algorithm/2023/11/20/insertion-sort.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-20T23:15:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Insertion Sort" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-20T23:15:00+02:00","datePublished":"2023-11-20T23:15:00+02:00","description":"Introduction Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high. Implementation Here is an implementation of insertion sort in OCaml: let rec insertion_sort = function | [] -&gt; [] | x :: xs -&gt; insert x (insertion_sort xs) and insert x = function | [] -&gt; [x] | y :: ys -&gt; if x &lt; y then x :: y :: ys else y :: insert x ys This implementation uses a recursive function to sort the list. The insertion_sort function takes a list as input and returns a sorted list. The insert function takes an element x and a sorted list as input and returns a new sorted list with x inserted in the correct position. Step-by-step Explanation The insertion_sort function is called with a list as input. If the list is empty, an empty list is returned. Otherwise, the first element x is removed from the list and the insert function is called with x and the sorted list returned by a recursive call to insertion_sort. The insert function takes x and a sorted list as input. If the list is empty, a list with x as the only element is returned. Otherwise, the first element y is removed from the list and the insert function is called recursively with x and the remaining list ys. If x is less than y, a new list with x and y followed by ys is returned. Otherwise, a new list with y followed by the result of calling insert with x and ys is returned. The sorted list returned by insert is returned by insertion_sort. Complexity Analysis The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory.","headline":"Insertion Sort","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/algorithm/2023/11/20/insertion-sort.html"},"url":"/blog/algorithm/2023/11/20/insertion-sort.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/blog/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Insertion Sort</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-20T23:15:00+02:00" itemprop="datePublished">
        Nov 20, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of insertion sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">insertion_sort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">insertion_sort</span> <span class="n">xs</span><span class="p">)</span>  
<span class="ow">and</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>  
  <span class="o">|</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">ys</span>  
</code></pre></div></div>

<p>This implementation uses a recursive function to sort the list. The <code class="language-plaintext highlighter-rouge">insertion_sort</code> function takes a list as input and returns a sorted list. The <code class="language-plaintext highlighter-rouge">insert</code> function takes an element <code class="language-plaintext highlighter-rouge">x</code> and a sorted list as input and returns a new sorted list with <code class="language-plaintext highlighter-rouge">x</code> inserted in the correct position.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>The <code class="language-plaintext highlighter-rouge">insertion_sort</code> function is called with a list as input.</li>
  <li>If the list is empty, an empty list is returned.</li>
  <li>Otherwise, the first element <code class="language-plaintext highlighter-rouge">x</code> is removed from the list and the <code class="language-plaintext highlighter-rouge">insert</code> function is called with <code class="language-plaintext highlighter-rouge">x</code> and the sorted list returned by a recursive call to <code class="language-plaintext highlighter-rouge">insertion_sort</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">insert</code> function takes <code class="language-plaintext highlighter-rouge">x</code> and a sorted list as input.</li>
  <li>If the list is empty, a list with <code class="language-plaintext highlighter-rouge">x</code> as the only element is returned.</li>
  <li>Otherwise, the first element <code class="language-plaintext highlighter-rouge">y</code> is removed from the list and the <code class="language-plaintext highlighter-rouge">insert</code> function is called recursively with <code class="language-plaintext highlighter-rouge">x</code> and the remaining list <code class="language-plaintext highlighter-rouge">ys</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">x</code> is less than <code class="language-plaintext highlighter-rouge">y</code>, a new list with <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> followed by <code class="language-plaintext highlighter-rouge">ys</code> is returned.</li>
  <li>Otherwise, a new list with <code class="language-plaintext highlighter-rouge">y</code> followed by the result of calling <code class="language-plaintext highlighter-rouge">insert</code> with <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">ys</code> is returned.</li>
  <li>The sorted list returned by <code class="language-plaintext highlighter-rouge">insert</code> is returned by <code class="language-plaintext highlighter-rouge">insertion_sort</code>.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory.</p>

  </div><a class="u-url" href="/blog/algorithm/2023/11/20/insertion-sort.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>A collection of classic algorithms, written in OCaml.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>

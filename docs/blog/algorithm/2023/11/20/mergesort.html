<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Merge Sort | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Merge Sort" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Merge sort is a divide-and-conquer algorithm that sorts an array or list of elements by recursively dividing it into two halves, sorting each half, and then merging the sorted halves back together. It is a highly efficient sorting algorithm with a time complexity of O(n log n), making it suitable for large datasets. Merge sort is widely used in various applications, including sorting large databases, numerical analysis, and parallel computing. Implementation Here is an implementation of merge sort in OCaml: let rec merge_sort = function | [] -&gt; [] | [x] -&gt; [x] | xs -&gt; let rec split left right = function | [] -&gt; (left, right) | x :: xs -&gt; split right (x :: left) xs in let rec merge left right = match left, right with | [], _ -&gt; right | _, [] -&gt; left | x :: xs, y :: ys -&gt; if x &lt; y then x :: merge xs right else y :: merge left ys in let left, right = split [] [] xs in merge (merge_sort left) (merge_sort right) Here is an example of using this implementation to sort a list of integers: let sorted_list = merge_sort [4; 2; 7; 1; 3; 6; 5];; The resulting sorted_list will be [1; 2; 3; 4; 5; 6; 7]. Step-by-step Explanation The merge_sort function takes a list of elements as input. If the list is empty or contains only one element, it is already sorted, so the function returns the list as is. Otherwise, the function recursively divides the list into two halves using the split function. The split function takes two empty lists (left and right) and the original list as input. If the original list is empty, the function returns the two half lists. Otherwise, the function takes the first element of the original list and adds it to the right list, while the rest of the list is recursively split with the right list becoming the new left list. The merge function takes two sorted lists (left and right) as input and returns a single sorted list. If one of the input lists is empty, the function returns the other list as is. Otherwise, the function compares the first elements of the two lists and adds the smaller one to the output list. The function then recursively calls itself with the remaining elements of the input lists until both input lists are empty. Finally, the merge_sort function merges the two sorted halves of the original list using the merge function. Complexity Analysis The time complexity of merge sort is O(n log n), where n is the number of elements in the input list. This is because the algorithm recursively divides the input list into halves until each half contains only one element, which takes O(log n) time. Then, the algorithm merges the sorted halves back together, which takes O(n) time. Therefore, the total time complexity is O(n log n). The space complexity of merge sort is O(n), where n is the number of elements in the input list. This is because the algorithm creates temporary lists to store the halves of the input list during the merge process. However, these temporary lists are deallocated after each recursive call, so the overall space complexity is O(n)." />
<meta property="og:description" content="Introduction Merge sort is a divide-and-conquer algorithm that sorts an array or list of elements by recursively dividing it into two halves, sorting each half, and then merging the sorted halves back together. It is a highly efficient sorting algorithm with a time complexity of O(n log n), making it suitable for large datasets. Merge sort is widely used in various applications, including sorting large databases, numerical analysis, and parallel computing. Implementation Here is an implementation of merge sort in OCaml: let rec merge_sort = function | [] -&gt; [] | [x] -&gt; [x] | xs -&gt; let rec split left right = function | [] -&gt; (left, right) | x :: xs -&gt; split right (x :: left) xs in let rec merge left right = match left, right with | [], _ -&gt; right | _, [] -&gt; left | x :: xs, y :: ys -&gt; if x &lt; y then x :: merge xs right else y :: merge left ys in let left, right = split [] [] xs in merge (merge_sort left) (merge_sort right) Here is an example of using this implementation to sort a list of integers: let sorted_list = merge_sort [4; 2; 7; 1; 3; 6; 5];; The resulting sorted_list will be [1; 2; 3; 4; 5; 6; 7]. Step-by-step Explanation The merge_sort function takes a list of elements as input. If the list is empty or contains only one element, it is already sorted, so the function returns the list as is. Otherwise, the function recursively divides the list into two halves using the split function. The split function takes two empty lists (left and right) and the original list as input. If the original list is empty, the function returns the two half lists. Otherwise, the function takes the first element of the original list and adds it to the right list, while the rest of the list is recursively split with the right list becoming the new left list. The merge function takes two sorted lists (left and right) as input and returns a single sorted list. If one of the input lists is empty, the function returns the other list as is. Otherwise, the function compares the first elements of the two lists and adds the smaller one to the output list. The function then recursively calls itself with the remaining elements of the input lists until both input lists are empty. Finally, the merge_sort function merges the two sorted halves of the original list using the merge function. Complexity Analysis The time complexity of merge sort is O(n log n), where n is the number of elements in the input list. This is because the algorithm recursively divides the input list into halves until each half contains only one element, which takes O(log n) time. Then, the algorithm merges the sorted halves back together, which takes O(n) time. Therefore, the total time complexity is O(n log n). The space complexity of merge sort is O(n), where n is the number of elements in the input list. This is because the algorithm creates temporary lists to store the halves of the input list during the merge process. However, these temporary lists are deallocated after each recursive call, so the overall space complexity is O(n)." />
<link rel="canonical" href="/blog/algorithm/2023/11/20/mergesort.html" />
<meta property="og:url" content="/blog/algorithm/2023/11/20/mergesort.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-20T23:01:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Merge Sort" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-20T23:01:00+02:00","datePublished":"2023-11-20T23:01:00+02:00","description":"Introduction Merge sort is a divide-and-conquer algorithm that sorts an array or list of elements by recursively dividing it into two halves, sorting each half, and then merging the sorted halves back together. It is a highly efficient sorting algorithm with a time complexity of O(n log n), making it suitable for large datasets. Merge sort is widely used in various applications, including sorting large databases, numerical analysis, and parallel computing. Implementation Here is an implementation of merge sort in OCaml: let rec merge_sort = function | [] -&gt; [] | [x] -&gt; [x] | xs -&gt; let rec split left right = function | [] -&gt; (left, right) | x :: xs -&gt; split right (x :: left) xs in let rec merge left right = match left, right with | [], _ -&gt; right | _, [] -&gt; left | x :: xs, y :: ys -&gt; if x &lt; y then x :: merge xs right else y :: merge left ys in let left, right = split [] [] xs in merge (merge_sort left) (merge_sort right) Here is an example of using this implementation to sort a list of integers: let sorted_list = merge_sort [4; 2; 7; 1; 3; 6; 5];; The resulting sorted_list will be [1; 2; 3; 4; 5; 6; 7]. Step-by-step Explanation The merge_sort function takes a list of elements as input. If the list is empty or contains only one element, it is already sorted, so the function returns the list as is. Otherwise, the function recursively divides the list into two halves using the split function. The split function takes two empty lists (left and right) and the original list as input. If the original list is empty, the function returns the two half lists. Otherwise, the function takes the first element of the original list and adds it to the right list, while the rest of the list is recursively split with the right list becoming the new left list. The merge function takes two sorted lists (left and right) as input and returns a single sorted list. If one of the input lists is empty, the function returns the other list as is. Otherwise, the function compares the first elements of the two lists and adds the smaller one to the output list. The function then recursively calls itself with the remaining elements of the input lists until both input lists are empty. Finally, the merge_sort function merges the two sorted halves of the original list using the merge function. Complexity Analysis The time complexity of merge sort is O(n log n), where n is the number of elements in the input list. This is because the algorithm recursively divides the input list into halves until each half contains only one element, which takes O(log n) time. Then, the algorithm merges the sorted halves back together, which takes O(n) time. Therefore, the total time complexity is O(n log n). The space complexity of merge sort is O(n), where n is the number of elements in the input list. This is because the algorithm creates temporary lists to store the halves of the input list during the merge process. However, these temporary lists are deallocated after each recursive call, so the overall space complexity is O(n).","headline":"Merge Sort","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/algorithm/2023/11/20/mergesort.html"},"url":"/blog/algorithm/2023/11/20/mergesort.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/blog/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Merge Sort</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-20T23:01:00+02:00" itemprop="datePublished">
        Nov 20, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>

<p>Merge sort is a divide-and-conquer algorithm that sorts an array or list of elements by recursively dividing it into two halves, sorting each half, and then merging the sorted halves back together. It is a highly efficient sorting algorithm with a time complexity of O(n log n), making it suitable for large datasets. Merge sort is widely used in various applications, including sorting large databases, numerical analysis, and parallel computing.</p>

<h2 id="implementation">Implementation</h2>

<p>Here is an implementation of merge sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">merge_sort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>  
  <span class="o">|</span> <span class="n">xs</span> <span class="o">-&gt;</span>  
      <span class="k">let</span> <span class="k">rec</span> <span class="n">split</span> <span class="n">left</span> <span class="n">right</span> <span class="o">=</span> <span class="k">function</span>  
        <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span>  
        <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">split</span> <span class="n">right</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">left</span><span class="p">)</span> <span class="n">xs</span>  
      <span class="k">in</span>  
      <span class="k">let</span> <span class="k">rec</span> <span class="n">merge</span> <span class="n">left</span> <span class="n">right</span> <span class="o">=</span> <span class="k">match</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="k">with</span>  
        <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">right</span>  
        <span class="o">|</span> <span class="n">_</span><span class="o">,</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">left</span>  
        <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span>  
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">merge</span> <span class="n">xs</span> <span class="n">right</span>  
            <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">merge</span> <span class="n">left</span> <span class="n">ys</span>  
      <span class="k">in</span>  
      <span class="k">let</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">split</span> <span class="bp">[]</span> <span class="bp">[]</span> <span class="n">xs</span> <span class="k">in</span>  
      <span class="n">merge</span> <span class="p">(</span><span class="n">merge_sort</span> <span class="n">left</span><span class="p">)</span> <span class="p">(</span><span class="n">merge_sort</span> <span class="n">right</span><span class="p">)</span>  
</code></pre></div></div>

<p>Here is an example of using this implementation to sort a list of integers:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">sorted_list</span> <span class="o">=</span> <span class="n">merge_sort</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">5</span><span class="p">];;</span>  
</code></pre></div></div>

<p>The resulting <code class="language-plaintext highlighter-rouge">sorted_list</code> will be <code class="language-plaintext highlighter-rouge">[1; 2; 3; 4; 5; 6; 7]</code>.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">merge_sort</code> function takes a list of elements as input.</li>
  <li>If the list is empty or contains only one element, it is already sorted, so the function returns the list as is.</li>
  <li>Otherwise, the function recursively divides the list into two halves using the <code class="language-plaintext highlighter-rouge">split</code> function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">split</code> function takes two empty lists (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) and the original list as input.</li>
  <li>If the original list is empty, the function returns the two half lists.</li>
  <li>Otherwise, the function takes the first element of the original list and adds it to the <code class="language-plaintext highlighter-rouge">right</code> list, while the rest of the list is recursively split with the <code class="language-plaintext highlighter-rouge">right</code> list becoming the new <code class="language-plaintext highlighter-rouge">left</code> list.</li>
  <li>The <code class="language-plaintext highlighter-rouge">merge</code> function takes two sorted lists (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) as input and returns a single sorted list.</li>
  <li>If one of the input lists is empty, the function returns the other list as is.</li>
  <li>Otherwise, the function compares the first elements of the two lists and adds the smaller one to the output list.</li>
  <li>The function then recursively calls itself with the remaining elements of the input lists until both input lists are empty.</li>
  <li>Finally, the <code class="language-plaintext highlighter-rouge">merge_sort</code> function merges the two sorted halves of the original list using the <code class="language-plaintext highlighter-rouge">merge</code> function.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The time complexity of merge sort is O(n log n), where n is the number of elements in the input list. This is because the algorithm recursively divides the input list into halves until each half contains only one element, which takes O(log n) time. Then, the algorithm merges the sorted halves back together, which takes O(n) time. Therefore, the total time complexity is O(n log n).</p>

<p>The space complexity of merge sort is O(n), where n is the number of elements in the input list. This is because the algorithm creates temporary lists to store the halves of the input list during the merge process. However, these temporary lists are deallocated after each recursive call, so the overall space complexity is O(n).</p>

  </div><a class="u-url" href="/blog/algorithm/2023/11/20/mergesort.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>A collection of classic algorithms, written in OCaml.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>

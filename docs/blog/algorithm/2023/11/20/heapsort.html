<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Heapsort | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Heapsort" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Heapsort is a comparison-based sorting algorithm that uses a binary heap data structure. It was first proposed by J. W. J. Williams in 1964. Heapsort is an in-place algorithm, meaning that it sorts the array in place, without needing any additional memory. It has a time complexity of O(n log n), which makes it efficient for large data sets. Implementation Here is an implementation of heapsort in OCaml: let swap arr i j = let temp = arr.(i) in arr.(i) &lt;- arr.(j); arr.(j) &lt;- temp let rec heapify arr n i = let largest = ref i in let left = 2 * i + 1 in let right = 2 * i + 2 in if left &lt; n &amp;&amp; arr.(left) &gt; arr.(!largest) then largest := left; if right &lt; n &amp;&amp; arr.(right) &gt; arr.(!largest) then largest := right; if !largest &lt;&gt; i then ( swap arr i !largest; heapify arr n !largest ) let heapsort arr = let n = Array.length arr in for i = n / 2 - 1 downto 0 do heapify arr n i done; for i = n - 1 downto 1 do swap arr 0 i; heapify arr i 0 done Here is an example of how to use the heapsort function: let arr = [|4; 2; 7; 1; 3|] in heapsort arr; Array.iter (Printf.printf &quot;%d &quot;) arr Output: 1 2 3 4 7 Step-by-step Explanation Build a max heap from the input data. A binary heap is a complete binary tree where each node is greater than or equal to its children. The largest element is stored at the root of the heap. Swap the root node with the last element in the array. Decrease the heap size by 1. Call heapify on the root node to restore the heap property. Repeat steps 2-3 until the heap size is 1. The heapify function takes three arguments: the array to be sorted, the size of the heap, and the index of the current node. It compares the current node with its left and right children and swaps it with the largest child if necessary. It then recursively calls heapify on the largest child to ensure that the subtree rooted at the current node is also a heap. Complexity Analysis The time complexity of heapsort is O(n log n) in the worst case. Building the heap takes O(n) time, and each call to heapify takes O(log n) time. We call heapify n-1 times in the second loop, so the total time complexity is O(n log n). Heapsort is an in-place sorting algorithm, so it requires no additional memory beyond the array to be sorted. However, it is not a stable sorting algorithm, meaning that it does not preserve the relative order of equal elements in the input array." />
<meta property="og:description" content="Introduction Heapsort is a comparison-based sorting algorithm that uses a binary heap data structure. It was first proposed by J. W. J. Williams in 1964. Heapsort is an in-place algorithm, meaning that it sorts the array in place, without needing any additional memory. It has a time complexity of O(n log n), which makes it efficient for large data sets. Implementation Here is an implementation of heapsort in OCaml: let swap arr i j = let temp = arr.(i) in arr.(i) &lt;- arr.(j); arr.(j) &lt;- temp let rec heapify arr n i = let largest = ref i in let left = 2 * i + 1 in let right = 2 * i + 2 in if left &lt; n &amp;&amp; arr.(left) &gt; arr.(!largest) then largest := left; if right &lt; n &amp;&amp; arr.(right) &gt; arr.(!largest) then largest := right; if !largest &lt;&gt; i then ( swap arr i !largest; heapify arr n !largest ) let heapsort arr = let n = Array.length arr in for i = n / 2 - 1 downto 0 do heapify arr n i done; for i = n - 1 downto 1 do swap arr 0 i; heapify arr i 0 done Here is an example of how to use the heapsort function: let arr = [|4; 2; 7; 1; 3|] in heapsort arr; Array.iter (Printf.printf &quot;%d &quot;) arr Output: 1 2 3 4 7 Step-by-step Explanation Build a max heap from the input data. A binary heap is a complete binary tree where each node is greater than or equal to its children. The largest element is stored at the root of the heap. Swap the root node with the last element in the array. Decrease the heap size by 1. Call heapify on the root node to restore the heap property. Repeat steps 2-3 until the heap size is 1. The heapify function takes three arguments: the array to be sorted, the size of the heap, and the index of the current node. It compares the current node with its left and right children and swaps it with the largest child if necessary. It then recursively calls heapify on the largest child to ensure that the subtree rooted at the current node is also a heap. Complexity Analysis The time complexity of heapsort is O(n log n) in the worst case. Building the heap takes O(n) time, and each call to heapify takes O(log n) time. We call heapify n-1 times in the second loop, so the total time complexity is O(n log n). Heapsort is an in-place sorting algorithm, so it requires no additional memory beyond the array to be sorted. However, it is not a stable sorting algorithm, meaning that it does not preserve the relative order of equal elements in the input array." />
<link rel="canonical" href="/blog/algorithm/2023/11/20/heapsort.html" />
<meta property="og:url" content="/blog/algorithm/2023/11/20/heapsort.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-20T22:04:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Heapsort" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-20T22:04:00+02:00","datePublished":"2023-11-20T22:04:00+02:00","description":"Introduction Heapsort is a comparison-based sorting algorithm that uses a binary heap data structure. It was first proposed by J. W. J. Williams in 1964. Heapsort is an in-place algorithm, meaning that it sorts the array in place, without needing any additional memory. It has a time complexity of O(n log n), which makes it efficient for large data sets. Implementation Here is an implementation of heapsort in OCaml: let swap arr i j = let temp = arr.(i) in arr.(i) &lt;- arr.(j); arr.(j) &lt;- temp let rec heapify arr n i = let largest = ref i in let left = 2 * i + 1 in let right = 2 * i + 2 in if left &lt; n &amp;&amp; arr.(left) &gt; arr.(!largest) then largest := left; if right &lt; n &amp;&amp; arr.(right) &gt; arr.(!largest) then largest := right; if !largest &lt;&gt; i then ( swap arr i !largest; heapify arr n !largest ) let heapsort arr = let n = Array.length arr in for i = n / 2 - 1 downto 0 do heapify arr n i done; for i = n - 1 downto 1 do swap arr 0 i; heapify arr i 0 done Here is an example of how to use the heapsort function: let arr = [|4; 2; 7; 1; 3|] in heapsort arr; Array.iter (Printf.printf &quot;%d &quot;) arr Output: 1 2 3 4 7 Step-by-step Explanation Build a max heap from the input data. A binary heap is a complete binary tree where each node is greater than or equal to its children. The largest element is stored at the root of the heap. Swap the root node with the last element in the array. Decrease the heap size by 1. Call heapify on the root node to restore the heap property. Repeat steps 2-3 until the heap size is 1. The heapify function takes three arguments: the array to be sorted, the size of the heap, and the index of the current node. It compares the current node with its left and right children and swaps it with the largest child if necessary. It then recursively calls heapify on the largest child to ensure that the subtree rooted at the current node is also a heap. Complexity Analysis The time complexity of heapsort is O(n log n) in the worst case. Building the heap takes O(n) time, and each call to heapify takes O(log n) time. We call heapify n-1 times in the second loop, so the total time complexity is O(n log n). Heapsort is an in-place sorting algorithm, so it requires no additional memory beyond the array to be sorted. However, it is not a stable sorting algorithm, meaning that it does not preserve the relative order of equal elements in the input array.","headline":"Heapsort","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/algorithm/2023/11/20/heapsort.html"},"url":"/blog/algorithm/2023/11/20/heapsort.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/blog/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Heapsort</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-20T22:04:00+02:00" itemprop="datePublished">
        Nov 20, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>Heapsort is a comparison-based sorting algorithm that uses a binary heap data structure. It was first proposed by J. W. J. Williams in 1964. Heapsort is an in-place algorithm, meaning that it sorts the array in place, without needing any additional memory. It has a time complexity of O(n log n), which makes it efficient for large data sets.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of heapsort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">swap</span> <span class="n">arr</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>  
  <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>  
  <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">temp</span>  
   
<span class="k">let</span> <span class="k">rec</span> <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="n">i</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">i</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">in</span>  
  <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">largest</span><span class="p">)</span> <span class="k">then</span>  
    <span class="n">largest</span> <span class="o">:=</span> <span class="n">left</span><span class="p">;</span>  
  <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">largest</span><span class="p">)</span> <span class="k">then</span>  
    <span class="n">largest</span> <span class="o">:=</span> <span class="n">right</span><span class="p">;</span>  
  <span class="k">if</span> <span class="o">!</span><span class="n">largest</span> <span class="o">&lt;&gt;</span> <span class="n">i</span> <span class="k">then</span> <span class="p">(</span>  
    <span class="n">swap</span> <span class="n">arr</span> <span class="n">i</span> <span class="o">!</span><span class="n">largest</span><span class="p">;</span>  
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="o">!</span><span class="n">largest</span>  
  <span class="p">)</span>  
   
<span class="k">let</span> <span class="n">heapsort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>  
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="n">i</span>  
  <span class="k">done</span><span class="p">;</span>  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">1</span> <span class="k">do</span>  
    <span class="n">swap</span> <span class="n">arr</span> <span class="mi">0</span> <span class="n">i</span><span class="p">;</span>  
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">i</span> <span class="mi">0</span>  
  <span class="k">done</span>  
</code></pre></div></div>

<p>Here is an example of how to use the heapsort function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span><span class="mi">4</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">3</span><span class="o">|</span><span class="p">]</span> <span class="k">in</span>  
<span class="n">heapsort</span> <span class="n">arr</span><span class="p">;</span>  
<span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"%d "</span><span class="p">)</span> <span class="n">arr</span>  
</code></pre></div></div>

<p>Output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 2 3 4 7  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Build a max heap from the input data. A binary heap is a complete binary tree where each node is greater than or equal to its children. The largest element is stored at the root of the heap.</li>
  <li>Swap the root node with the last element in the array. Decrease the heap size by 1.</li>
  <li>Call heapify on the root node to restore the heap property.</li>
  <li>Repeat steps 2-3 until the heap size is 1.</li>
</ol>

<p>The heapify function takes three arguments: the array to be sorted, the size of the heap, and the index of the current node. It compares the current node with its left and right children and swaps it with the largest child if necessary. It then recursively calls heapify on the largest child to ensure that the subtree rooted at the current node is also a heap.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of heapsort is O(n log n) in the worst case. Building the heap takes O(n) time, and each call to heapify takes O(log n) time. We call heapify n-1 times in the second loop, so the total time complexity is O(n log n).</p>

<p>Heapsort is an in-place sorting algorithm, so it requires no additional memory beyond the array to be sorted. However, it is not a stable sorting algorithm, meaning that it does not preserve the relative order of equal elements in the input array.</p>

  </div><a class="u-url" href="/blog/algorithm/2023/11/20/heapsort.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>A collection of classic algorithms, written in OCaml.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>

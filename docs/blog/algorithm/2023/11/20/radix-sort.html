<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Radix Sort | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Radix Sort" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Radix sort is a sorting algorithm that sorts elements by grouping them based on their digits or bits. It is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping the keys by individual digits that share the same significant position and value. Radix sort is often used for sorting large numbers of records, such as in big data applications. Implementation Here is an implementation of radix sort in OCaml: let radix_sort arr = let rec loop arr exp = if exp &lt; 0 then arr else let zeroes, ones = List.partition (fun x -&gt; x land (1 lsl exp) = 0) arr in loop zeroes (exp - 1) @ loop ones (exp - 1) in loop arr (List.fold_left (fun m x -&gt; max m (int_of_float (log10 (float_of_int x)))) 0 arr) Here, radix_sort takes in an array of integers arr and returns a sorted array. The loop function recursively sorts the array by partitioning it into two subarrays based on the value of the exp-th bit (starting from the most significant bit). The exp parameter is initially set to the maximum number of digits in any element of the array. The function log10 is used to calculate the number of digits in each element. Step-by-step Explanation Find the maximum number of digits in any element of the array. For each bit position starting from the most significant bit, partition the array into two subarrays based on the value of that bit. Recursively sort each subarray by repeating step 2 with the next bit position. Concatenate the sorted subarrays to get the final sorted array. For example, let’s say we have the following array: [170, 45, 75, 90, 802, 24, 2, 66] The maximum number of digits is 3, so we start by partitioning the array based on the third bit: [170, 90, 802, 2, 24, 45, 75, 66] We then recursively sort each subarray by partitioning based on the second bit: [802, 2, 24, 45, 66, 170, 75, 90] [2, 24, 45, 66, 75, 90, 170, 802] Finally, we concatenate the sorted subarrays to get the final sorted array: [2, 24, 45, 66, 75, 90, 170, 802] Complexity Analysis The time complexity of radix sort is O(d * (n + k)), where d is the maximum number of digits in any element of the array, n is the number of elements in the array, and k is the range of values (i.e., the maximum value minus the minimum value). The space complexity is O(n + k). In the worst case, when d is very large, radix sort can be slower than comparison-based sorting algorithms like quicksort or mergesort. However, radix sort has the advantage of being able to sort large integers and other non-comparable data types that cannot be easily sorted using comparison-based algorithms." />
<meta property="og:description" content="Introduction Radix sort is a sorting algorithm that sorts elements by grouping them based on their digits or bits. It is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping the keys by individual digits that share the same significant position and value. Radix sort is often used for sorting large numbers of records, such as in big data applications. Implementation Here is an implementation of radix sort in OCaml: let radix_sort arr = let rec loop arr exp = if exp &lt; 0 then arr else let zeroes, ones = List.partition (fun x -&gt; x land (1 lsl exp) = 0) arr in loop zeroes (exp - 1) @ loop ones (exp - 1) in loop arr (List.fold_left (fun m x -&gt; max m (int_of_float (log10 (float_of_int x)))) 0 arr) Here, radix_sort takes in an array of integers arr and returns a sorted array. The loop function recursively sorts the array by partitioning it into two subarrays based on the value of the exp-th bit (starting from the most significant bit). The exp parameter is initially set to the maximum number of digits in any element of the array. The function log10 is used to calculate the number of digits in each element. Step-by-step Explanation Find the maximum number of digits in any element of the array. For each bit position starting from the most significant bit, partition the array into two subarrays based on the value of that bit. Recursively sort each subarray by repeating step 2 with the next bit position. Concatenate the sorted subarrays to get the final sorted array. For example, let’s say we have the following array: [170, 45, 75, 90, 802, 24, 2, 66] The maximum number of digits is 3, so we start by partitioning the array based on the third bit: [170, 90, 802, 2, 24, 45, 75, 66] We then recursively sort each subarray by partitioning based on the second bit: [802, 2, 24, 45, 66, 170, 75, 90] [2, 24, 45, 66, 75, 90, 170, 802] Finally, we concatenate the sorted subarrays to get the final sorted array: [2, 24, 45, 66, 75, 90, 170, 802] Complexity Analysis The time complexity of radix sort is O(d * (n + k)), where d is the maximum number of digits in any element of the array, n is the number of elements in the array, and k is the range of values (i.e., the maximum value minus the minimum value). The space complexity is O(n + k). In the worst case, when d is very large, radix sort can be slower than comparison-based sorting algorithms like quicksort or mergesort. However, radix sort has the advantage of being able to sort large integers and other non-comparable data types that cannot be easily sorted using comparison-based algorithms." />
<link rel="canonical" href="/blog/algorithm/2023/11/20/radix-sort.html" />
<meta property="og:url" content="/blog/algorithm/2023/11/20/radix-sort.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-20T23:15:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Radix Sort" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-20T23:15:00+02:00","datePublished":"2023-11-20T23:15:00+02:00","description":"Introduction Radix sort is a sorting algorithm that sorts elements by grouping them based on their digits or bits. It is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping the keys by individual digits that share the same significant position and value. Radix sort is often used for sorting large numbers of records, such as in big data applications. Implementation Here is an implementation of radix sort in OCaml: let radix_sort arr = let rec loop arr exp = if exp &lt; 0 then arr else let zeroes, ones = List.partition (fun x -&gt; x land (1 lsl exp) = 0) arr in loop zeroes (exp - 1) @ loop ones (exp - 1) in loop arr (List.fold_left (fun m x -&gt; max m (int_of_float (log10 (float_of_int x)))) 0 arr) Here, radix_sort takes in an array of integers arr and returns a sorted array. The loop function recursively sorts the array by partitioning it into two subarrays based on the value of the exp-th bit (starting from the most significant bit). The exp parameter is initially set to the maximum number of digits in any element of the array. The function log10 is used to calculate the number of digits in each element. Step-by-step Explanation Find the maximum number of digits in any element of the array. For each bit position starting from the most significant bit, partition the array into two subarrays based on the value of that bit. Recursively sort each subarray by repeating step 2 with the next bit position. Concatenate the sorted subarrays to get the final sorted array. For example, let’s say we have the following array: [170, 45, 75, 90, 802, 24, 2, 66] The maximum number of digits is 3, so we start by partitioning the array based on the third bit: [170, 90, 802, 2, 24, 45, 75, 66] We then recursively sort each subarray by partitioning based on the second bit: [802, 2, 24, 45, 66, 170, 75, 90] [2, 24, 45, 66, 75, 90, 170, 802] Finally, we concatenate the sorted subarrays to get the final sorted array: [2, 24, 45, 66, 75, 90, 170, 802] Complexity Analysis The time complexity of radix sort is O(d * (n + k)), where d is the maximum number of digits in any element of the array, n is the number of elements in the array, and k is the range of values (i.e., the maximum value minus the minimum value). The space complexity is O(n + k). In the worst case, when d is very large, radix sort can be slower than comparison-based sorting algorithms like quicksort or mergesort. However, radix sort has the advantage of being able to sort large integers and other non-comparable data types that cannot be easily sorted using comparison-based algorithms.","headline":"Radix Sort","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/algorithm/2023/11/20/radix-sort.html"},"url":"/blog/algorithm/2023/11/20/radix-sort.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/blog/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Radix Sort</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-20T23:15:00+02:00" itemprop="datePublished">
        Nov 20, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>Radix sort is a sorting algorithm that sorts elements by grouping them based on their digits or bits. It is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping the keys by individual digits that share the same significant position and value. Radix sort is often used for sorting large numbers of records, such as in big data applications.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of radix sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">radix_sort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="n">arr</span> <span class="n">exp</span> <span class="o">=</span>  
    <span class="k">if</span> <span class="n">exp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">arr</span> <span class="k">else</span>  
      <span class="k">let</span> <span class="n">zeroes</span><span class="o">,</span> <span class="n">ones</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">partition</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="ow">land</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">lsl</span> <span class="n">exp</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">arr</span> <span class="k">in</span>  
      <span class="n">loop</span> <span class="n">zeroes</span> <span class="p">(</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">loop</span> <span class="n">ones</span> <span class="p">(</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  
  <span class="k">in</span>  
  <span class="n">loop</span> <span class="n">arr</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">m</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">max</span> <span class="n">m</span> <span class="p">(</span><span class="n">int_of_float</span> <span class="p">(</span><span class="n">log10</span> <span class="p">(</span><span class="n">float_of_int</span> <span class="n">x</span><span class="p">))))</span> <span class="mi">0</span> <span class="n">arr</span><span class="p">)</span>  
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">radix_sort</code> takes in an array of integers <code class="language-plaintext highlighter-rouge">arr</code> and returns a sorted array. The <code class="language-plaintext highlighter-rouge">loop</code> function recursively sorts the array by partitioning it into two subarrays based on the value of the <code class="language-plaintext highlighter-rouge">exp</code>-th bit (starting from the most significant bit). The <code class="language-plaintext highlighter-rouge">exp</code> parameter is initially set to the maximum number of digits in any element of the array. The function <code class="language-plaintext highlighter-rouge">log10</code> is used to calculate the number of digits in each element.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Find the maximum number of digits in any element of the array.</li>
  <li>For each bit position starting from the most significant bit, partition the array into two subarrays based on the value of that bit.</li>
  <li>Recursively sort each subarray by repeating step 2 with the next bit position.</li>
  <li>Concatenate the sorted subarrays to get the final sorted array.</li>
</ol>

<p>For example, let’s say we have the following array:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[170, 45, 75, 90, 802, 24, 2, 66]  
</code></pre></div></div>

<p>The maximum number of digits is 3, so we start by partitioning the array based on the third bit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[170, 90, 802, 2, 24, 45, 75, 66]  
</code></pre></div></div>

<p>We then recursively sort each subarray by partitioning based on the second bit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[802, 2, 24, 45, 66, 170, 75, 90]  
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[2, 24, 45, 66, 75, 90, 170, 802]  
</code></pre></div></div>

<p>Finally, we concatenate the sorted subarrays to get the final sorted array:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[2, 24, 45, 66, 75, 90, 170, 802]  
</code></pre></div></div>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of radix sort is O(d * (n + k)), where d is the maximum number of digits in any element of the array, n is the number of elements in the array, and k is the range of values (i.e., the maximum value minus the minimum value). The space complexity is O(n + k).</p>

<p>In the worst case, when d is very large, radix sort can be slower than comparison-based sorting algorithms like quicksort or mergesort. However, radix sort has the advantage of being able to sort large integers and other non-comparable data types that cannot be easily sorted using comparison-based algorithms.</p>

  </div><a class="u-url" href="/blog/algorithm/2023/11/20/radix-sort.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>A collection of classic algorithms, written in OCaml.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>

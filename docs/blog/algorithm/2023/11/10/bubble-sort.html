<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Bubble Sort | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Bubble Sort" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Bubble Sort is a simple sorting algorithm that repeatedly swaps adjacent elements if they are in the wrong order. It is named as bubble sort because the smaller elements bubble up to the top of the list as the algorithm iterates through the list. Bubble Sort is not an efficient algorithm for large lists and is generally used for educational purposes. Implementation Here is an implementation of Bubble Sort in OCaml: let bubble_sort arr = let n = Array.length arr in for i = 0 to n - 2 do for j = 0 to n - i - 2 do if arr.(j) &gt; arr.(j+1) then let temp = arr.(j) in arr.(j) &lt;- arr.(j+1); arr.(j+1) &lt;- temp done done;; Here, arr is the array to be sorted. The function bubble_sort uses two nested loops to iterate through the array and compare adjacent elements. If the elements are in the wrong order, they are swapped. The outer loop iterates from 0 to n-2, while the inner loop iterates from 0 to n-i-2. This is because the largest element in the list will already be in its correct position after each iteration of the outer loop. Step-by-step Explanation Start with an unsorted array of n elements. Compare the first two elements. If the first element is greater than the second element, swap them. Move to the next pair of adjacent elements and repeat step 2 until the end of the array is reached. Repeat steps 2 and 3 for each pair of adjacent elements until the end of the array is reached. After each iteration, the largest element will be in its correct position at the end of the array. Repeat steps 2-5 n-1 times to sort the entire array. Complexity Analysis The time complexity of Bubble Sort is O(n^2), where n is the number of elements in the array. This is because the algorithm uses two nested loops to iterate through the array and compare adjacent elements. In the worst case scenario, where the array is in reverse order, the algorithm will need to make n*(n-1)/2 comparisons and swaps. The space complexity of Bubble Sort is O(1), as the algorithm only requires a constant amount of additional memory to store temporary variables for swapping elements." />
<meta property="og:description" content="Introduction Bubble Sort is a simple sorting algorithm that repeatedly swaps adjacent elements if they are in the wrong order. It is named as bubble sort because the smaller elements bubble up to the top of the list as the algorithm iterates through the list. Bubble Sort is not an efficient algorithm for large lists and is generally used for educational purposes. Implementation Here is an implementation of Bubble Sort in OCaml: let bubble_sort arr = let n = Array.length arr in for i = 0 to n - 2 do for j = 0 to n - i - 2 do if arr.(j) &gt; arr.(j+1) then let temp = arr.(j) in arr.(j) &lt;- arr.(j+1); arr.(j+1) &lt;- temp done done;; Here, arr is the array to be sorted. The function bubble_sort uses two nested loops to iterate through the array and compare adjacent elements. If the elements are in the wrong order, they are swapped. The outer loop iterates from 0 to n-2, while the inner loop iterates from 0 to n-i-2. This is because the largest element in the list will already be in its correct position after each iteration of the outer loop. Step-by-step Explanation Start with an unsorted array of n elements. Compare the first two elements. If the first element is greater than the second element, swap them. Move to the next pair of adjacent elements and repeat step 2 until the end of the array is reached. Repeat steps 2 and 3 for each pair of adjacent elements until the end of the array is reached. After each iteration, the largest element will be in its correct position at the end of the array. Repeat steps 2-5 n-1 times to sort the entire array. Complexity Analysis The time complexity of Bubble Sort is O(n^2), where n is the number of elements in the array. This is because the algorithm uses two nested loops to iterate through the array and compare adjacent elements. In the worst case scenario, where the array is in reverse order, the algorithm will need to make n*(n-1)/2 comparisons and swaps. The space complexity of Bubble Sort is O(1), as the algorithm only requires a constant amount of additional memory to store temporary variables for swapping elements." />
<link rel="canonical" href="/blog/algorithm/2023/11/10/bubble-sort.html" />
<meta property="og:url" content="/blog/algorithm/2023/11/10/bubble-sort.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-10T18:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Bubble Sort" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-10T18:00:00+02:00","datePublished":"2023-11-10T18:00:00+02:00","description":"Introduction Bubble Sort is a simple sorting algorithm that repeatedly swaps adjacent elements if they are in the wrong order. It is named as bubble sort because the smaller elements bubble up to the top of the list as the algorithm iterates through the list. Bubble Sort is not an efficient algorithm for large lists and is generally used for educational purposes. Implementation Here is an implementation of Bubble Sort in OCaml: let bubble_sort arr = let n = Array.length arr in for i = 0 to n - 2 do for j = 0 to n - i - 2 do if arr.(j) &gt; arr.(j+1) then let temp = arr.(j) in arr.(j) &lt;- arr.(j+1); arr.(j+1) &lt;- temp done done;; Here, arr is the array to be sorted. The function bubble_sort uses two nested loops to iterate through the array and compare adjacent elements. If the elements are in the wrong order, they are swapped. The outer loop iterates from 0 to n-2, while the inner loop iterates from 0 to n-i-2. This is because the largest element in the list will already be in its correct position after each iteration of the outer loop. Step-by-step Explanation Start with an unsorted array of n elements. Compare the first two elements. If the first element is greater than the second element, swap them. Move to the next pair of adjacent elements and repeat step 2 until the end of the array is reached. Repeat steps 2 and 3 for each pair of adjacent elements until the end of the array is reached. After each iteration, the largest element will be in its correct position at the end of the array. Repeat steps 2-5 n-1 times to sort the entire array. Complexity Analysis The time complexity of Bubble Sort is O(n^2), where n is the number of elements in the array. This is because the algorithm uses two nested loops to iterate through the array and compare adjacent elements. In the worst case scenario, where the array is in reverse order, the algorithm will need to make n*(n-1)/2 comparisons and swaps. The space complexity of Bubble Sort is O(1), as the algorithm only requires a constant amount of additional memory to store temporary variables for swapping elements.","headline":"Bubble Sort","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/algorithm/2023/11/10/bubble-sort.html"},"url":"/blog/algorithm/2023/11/10/bubble-sort.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/blog/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Bubble Sort</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-10T18:00:00+02:00" itemprop="datePublished">
        Nov 10, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>Bubble Sort is a simple sorting algorithm that repeatedly swaps adjacent elements if they are in the wrong order. It is named as bubble sort because the smaller elements bubble up to the top of the list as the algorithm iterates through the list. Bubble Sort is not an efficient algorithm for large lists and is generally used for educational purposes.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of Bubble Sort in OCaml:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let bubble_sort arr =  
  let n = Array.length arr in  
  for i = 0 to n - 2 do  
    for j = 0 to n - i - 2 do  
      if arr.(j) &gt; arr.(j+1) then  
        let temp = arr.(j) in  
        arr.(j) &lt;- arr.(j+1);  
        arr.(j+1) &lt;- temp  
    done  
  done;;  
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">arr</code> is the array to be sorted. The function <code class="language-plaintext highlighter-rouge">bubble_sort</code> uses two nested loops to iterate through the array and compare adjacent elements. If the elements are in the wrong order, they are swapped. The outer loop iterates from 0 to n-2, while the inner loop iterates from 0 to n-i-2. This is because the largest element in the list will already be in its correct position after each iteration of the outer loop.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Start with an unsorted array of n elements.</li>
  <li>Compare the first two elements. If the first element is greater than the second element, swap them.</li>
  <li>Move to the next pair of adjacent elements and repeat step 2 until the end of the array is reached.</li>
  <li>Repeat steps 2 and 3 for each pair of adjacent elements until the end of the array is reached.</li>
  <li>After each iteration, the largest element will be in its correct position at the end of the array.</li>
  <li>Repeat steps 2-5 n-1 times to sort the entire array.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Bubble Sort is O(n^2), where n is the number of elements in the array. This is because the algorithm uses two nested loops to iterate through the array and compare adjacent elements. In the worst case scenario, where the array is in reverse order, the algorithm will need to make n*(n-1)/2 comparisons and swaps. The space complexity of Bubble Sort is O(1), as the algorithm only requires a constant amount of additional memory to store temporary variables for swapping elements.</p>

  </div><a class="u-url" href="/blog/algorithm/2023/11/10/bubble-sort.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>A collection of classic algorithms, written in OCaml.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>

<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Bucket Sort | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Bucket Sort" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Bucket sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm or by recursively applying the bucket sorting algorithm. Bucket sort is useful when the input is uniformly distributed over a range. It is commonly used in computer graphics, computational biology, and data mining. Implementation Here is an implementation of bucket sort in OCaml: let bucket_sort arr = let n = Array.length arr in let buckets = Array.make n [] in for i = 0 to n - 1 do let bucket_index = int_of_float (arr.(i) *. (float_of_int n)) in buckets.(bucket_index) &lt;- arr.(i) :: buckets.(bucket_index) done; let sorted = ref [] in for i = 0 to n - 1 do buckets.(i) &lt;- List.sort compare buckets.(i); sorted := !sorted @ buckets.(i) done; Array.of_list !sorted This implementation takes an array of floating-point numbers as input and returns a sorted array. Step-by-step Explanation The input array is first traversed to determine the number of buckets required. This is done by taking the length of the array and creating an empty bucket for each index. let n = Array.length arr in let buckets = Array.make n [] in The elements of the array are then distributed into the buckets. This is done by iterating over the array and calculating the index of the bucket for each element. The index is calculated by multiplying the element by the number of buckets and taking the integer part of the result. for i = 0 to n - 1 do let bucket_index = int_of_float (arr.(i) *. (float_of_int n)) in buckets.(bucket_index) &lt;- arr.(i) :: buckets.(bucket_index) done; Each bucket is then sorted individually. This is done using the OCaml List.sort function, which sorts a list in ascending order using the compare function. for i = 0 to n - 1 do buckets.(i) &lt;- List.sort compare buckets.(i); done; Finally, the sorted elements are concatenated to form the final sorted array. let sorted = ref [] in for i = 0 to n - 1 do sorted := !sorted @ buckets.(i) done; Array.of_list !sorted Complexity Analysis The time complexity of bucket sort depends on the sorting algorithm used to sort the individual buckets. In the worst case, if each bucket contains all the elements of the input array, the time complexity of bucket sort is O(n^2), where n is the number of elements in the input array. However, if the input is uniformly distributed over a range, the time complexity can be improved to O(n) by using a linear-time sorting algorithm like counting sort or radix sort to sort the individual buckets. The space complexity of bucket sort is O(n), where n is the number of elements in the input array. This is because we need to create a bucket for each element in the input array. However, if the input is uniformly distributed over a range, the space complexity can be improved to O(k), where k is the number of buckets required, which is much smaller than n." />
<meta property="og:description" content="Introduction Bucket sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm or by recursively applying the bucket sorting algorithm. Bucket sort is useful when the input is uniformly distributed over a range. It is commonly used in computer graphics, computational biology, and data mining. Implementation Here is an implementation of bucket sort in OCaml: let bucket_sort arr = let n = Array.length arr in let buckets = Array.make n [] in for i = 0 to n - 1 do let bucket_index = int_of_float (arr.(i) *. (float_of_int n)) in buckets.(bucket_index) &lt;- arr.(i) :: buckets.(bucket_index) done; let sorted = ref [] in for i = 0 to n - 1 do buckets.(i) &lt;- List.sort compare buckets.(i); sorted := !sorted @ buckets.(i) done; Array.of_list !sorted This implementation takes an array of floating-point numbers as input and returns a sorted array. Step-by-step Explanation The input array is first traversed to determine the number of buckets required. This is done by taking the length of the array and creating an empty bucket for each index. let n = Array.length arr in let buckets = Array.make n [] in The elements of the array are then distributed into the buckets. This is done by iterating over the array and calculating the index of the bucket for each element. The index is calculated by multiplying the element by the number of buckets and taking the integer part of the result. for i = 0 to n - 1 do let bucket_index = int_of_float (arr.(i) *. (float_of_int n)) in buckets.(bucket_index) &lt;- arr.(i) :: buckets.(bucket_index) done; Each bucket is then sorted individually. This is done using the OCaml List.sort function, which sorts a list in ascending order using the compare function. for i = 0 to n - 1 do buckets.(i) &lt;- List.sort compare buckets.(i); done; Finally, the sorted elements are concatenated to form the final sorted array. let sorted = ref [] in for i = 0 to n - 1 do sorted := !sorted @ buckets.(i) done; Array.of_list !sorted Complexity Analysis The time complexity of bucket sort depends on the sorting algorithm used to sort the individual buckets. In the worst case, if each bucket contains all the elements of the input array, the time complexity of bucket sort is O(n^2), where n is the number of elements in the input array. However, if the input is uniformly distributed over a range, the time complexity can be improved to O(n) by using a linear-time sorting algorithm like counting sort or radix sort to sort the individual buckets. The space complexity of bucket sort is O(n), where n is the number of elements in the input array. This is because we need to create a bucket for each element in the input array. However, if the input is uniformly distributed over a range, the space complexity can be improved to O(k), where k is the number of buckets required, which is much smaller than n." />
<link rel="canonical" href="/blog/algorithm/2023/11/10/bucket-sort.html" />
<meta property="og:url" content="/blog/algorithm/2023/11/10/bucket-sort.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-10T11:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Bucket Sort" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-10T11:00:00+02:00","datePublished":"2023-11-10T11:00:00+02:00","description":"Introduction Bucket sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm or by recursively applying the bucket sorting algorithm. Bucket sort is useful when the input is uniformly distributed over a range. It is commonly used in computer graphics, computational biology, and data mining. Implementation Here is an implementation of bucket sort in OCaml: let bucket_sort arr = let n = Array.length arr in let buckets = Array.make n [] in for i = 0 to n - 1 do let bucket_index = int_of_float (arr.(i) *. (float_of_int n)) in buckets.(bucket_index) &lt;- arr.(i) :: buckets.(bucket_index) done; let sorted = ref [] in for i = 0 to n - 1 do buckets.(i) &lt;- List.sort compare buckets.(i); sorted := !sorted @ buckets.(i) done; Array.of_list !sorted This implementation takes an array of floating-point numbers as input and returns a sorted array. Step-by-step Explanation The input array is first traversed to determine the number of buckets required. This is done by taking the length of the array and creating an empty bucket for each index. let n = Array.length arr in let buckets = Array.make n [] in The elements of the array are then distributed into the buckets. This is done by iterating over the array and calculating the index of the bucket for each element. The index is calculated by multiplying the element by the number of buckets and taking the integer part of the result. for i = 0 to n - 1 do let bucket_index = int_of_float (arr.(i) *. (float_of_int n)) in buckets.(bucket_index) &lt;- arr.(i) :: buckets.(bucket_index) done; Each bucket is then sorted individually. This is done using the OCaml List.sort function, which sorts a list in ascending order using the compare function. for i = 0 to n - 1 do buckets.(i) &lt;- List.sort compare buckets.(i); done; Finally, the sorted elements are concatenated to form the final sorted array. let sorted = ref [] in for i = 0 to n - 1 do sorted := !sorted @ buckets.(i) done; Array.of_list !sorted Complexity Analysis The time complexity of bucket sort depends on the sorting algorithm used to sort the individual buckets. In the worst case, if each bucket contains all the elements of the input array, the time complexity of bucket sort is O(n^2), where n is the number of elements in the input array. However, if the input is uniformly distributed over a range, the time complexity can be improved to O(n) by using a linear-time sorting algorithm like counting sort or radix sort to sort the individual buckets. The space complexity of bucket sort is O(n), where n is the number of elements in the input array. This is because we need to create a bucket for each element in the input array. However, if the input is uniformly distributed over a range, the space complexity can be improved to O(k), where k is the number of buckets required, which is much smaller than n.","headline":"Bucket Sort","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/algorithm/2023/11/10/bucket-sort.html"},"url":"/blog/algorithm/2023/11/10/bucket-sort.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/blog/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Bucket Sort</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-10T11:00:00+02:00" itemprop="datePublished">
        Nov 10, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>Bucket sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm or by recursively applying the bucket sorting algorithm. Bucket sort is useful when the input is uniformly distributed over a range. It is commonly used in computer graphics, computational biology, and data mining.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of bucket sort in OCaml:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let bucket_sort arr =  
  let n = Array.length arr in  
  let buckets = Array.make n [] in  
  for i = 0 to n - 1 do  
    let bucket_index = int_of_float (arr.(i) *. (float_of_int n)) in  
    buckets.(bucket_index) &lt;- arr.(i) :: buckets.(bucket_index)  
  done;  
  let sorted = ref [] in  
  for i = 0 to n - 1 do  
    buckets.(i) &lt;- List.sort compare buckets.(i);  
    sorted := !sorted @ buckets.(i)  
  done;  
  Array.of_list !sorted  
</code></pre></div></div>

<p>This implementation takes an array of floating-point numbers as input and returns a sorted array.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>The input array is first traversed to determine the number of buckets required. This is done by taking the length of the array and creating an empty bucket for each index.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let n = Array.length arr in  
let buckets = Array.make n [] in  
</code></pre></div>    </div>
  </li>
  <li>The elements of the array are then distributed into the buckets. This is done by iterating over the array and calculating the index of the bucket for each element. The index is calculated by multiplying the element by the number of buckets and taking the integer part of the result.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i = 0 to n - 1 do  
  let bucket_index = int_of_float (arr.(i) *. (float_of_int n)) in  
  buckets.(bucket_index) &lt;- arr.(i) :: buckets.(bucket_index)  
done;  
</code></pre></div>    </div>
  </li>
  <li>Each bucket is then sorted individually. This is done using the OCaml <code class="language-plaintext highlighter-rouge">List.sort</code> function, which sorts a list in ascending order using the <code class="language-plaintext highlighter-rouge">compare</code> function.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i = 0 to n - 1 do  
  buckets.(i) &lt;- List.sort compare buckets.(i);  
done;  
</code></pre></div>    </div>
  </li>
  <li>Finally, the sorted elements are concatenated to form the final sorted array.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let sorted = ref [] in  
for i = 0 to n - 1 do  
  sorted := !sorted @ buckets.(i)  
done;  
Array.of_list !sorted  
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of bucket sort depends on the sorting algorithm used to sort the individual buckets. In the worst case, if each bucket contains all the elements of the input array, the time complexity of bucket sort is O(n^2), where n is the number of elements in the input array. However, if the input is uniformly distributed over a range, the time complexity can be improved to O(n) by using a linear-time sorting algorithm like counting sort or radix sort to sort the individual buckets.</p>

<p>The space complexity of bucket sort is O(n), where n is the number of elements in the input array. This is because we need to create a bucket for each element in the input array. However, if the input is uniformly distributed over a range, the space complexity can be improved to O(k), where k is the number of buckets required, which is much smaller than n.</p>

  </div><a class="u-url" href="/blog/algorithm/2023/11/10/bucket-sort.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>A collection of classic algorithms, written in OCaml.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>

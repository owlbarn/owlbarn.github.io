<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Selection Sort | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Selection Sort" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Selection sort is a simple sorting algorithm that works by repeatedly finding the minimum element from an unsorted list and putting it at the beginning. The algorithm is not very efficient for large lists, but it has the advantage of being simple to understand and implement. Implementation Here is an implementation of selection sort in OCaml: let rec find_min i arr = if i = Array.length arr then -1 else let min_idx = find_min (i+1) arr in if min_idx = -1 || arr.(i) &lt; arr.(min_idx) then i else min_idx let selection_sort arr = for i = 0 to Array.length arr - 1 do let min_idx = find_min i arr in let tmp = arr.(i) in arr.(i) &lt;- arr.(min_idx); arr.(min_idx) &lt;- tmp done Here, find_min is a helper function that finds the index of the minimum element in the array arr starting from index i. It returns -1 if i is already at the end of the array. selection_sort uses find_min to find the minimum element in the unsorted portion of the array and swaps it with the first element in the unsorted portion. This process is repeated until the entire array is sorted. Here is an example of using selection_sort: let arr = [|5; 2; 9; 3; 6|] selection_sort arr (* arr is now [|2; 3; 5; 6; 9|] *) Step-by-step Explanation We start with an unsorted array arr. We iterate over the array from index 0 to n-1, where n is the length of the array. For each iteration, we call find_min to find the index of the minimum element in the unsorted portion of the array starting from index i. We swap the element at index i with the minimum element found in step 3. We repeat steps 3-4 until the entire array is sorted. Complexity Analysis The time complexity of selection sort is O(n^2), where n is the length of the array. This is because we have to iterate over the entire array n times, and for each iteration, we have to find the minimum element in the unsorted portion of the array, which takes O(n) time. The space complexity of selection sort is O(1), because we only need to store a few variables to keep track of the indices and the temporary value during the swapping process. Selection sort is not very efficient for large arrays, but it has the advantage of being simple to implement and understand. It can also be useful in situations where memory is limited, since it only requires a constant amount of extra memory." />
<meta property="og:description" content="Introduction Selection sort is a simple sorting algorithm that works by repeatedly finding the minimum element from an unsorted list and putting it at the beginning. The algorithm is not very efficient for large lists, but it has the advantage of being simple to understand and implement. Implementation Here is an implementation of selection sort in OCaml: let rec find_min i arr = if i = Array.length arr then -1 else let min_idx = find_min (i+1) arr in if min_idx = -1 || arr.(i) &lt; arr.(min_idx) then i else min_idx let selection_sort arr = for i = 0 to Array.length arr - 1 do let min_idx = find_min i arr in let tmp = arr.(i) in arr.(i) &lt;- arr.(min_idx); arr.(min_idx) &lt;- tmp done Here, find_min is a helper function that finds the index of the minimum element in the array arr starting from index i. It returns -1 if i is already at the end of the array. selection_sort uses find_min to find the minimum element in the unsorted portion of the array and swaps it with the first element in the unsorted portion. This process is repeated until the entire array is sorted. Here is an example of using selection_sort: let arr = [|5; 2; 9; 3; 6|] selection_sort arr (* arr is now [|2; 3; 5; 6; 9|] *) Step-by-step Explanation We start with an unsorted array arr. We iterate over the array from index 0 to n-1, where n is the length of the array. For each iteration, we call find_min to find the index of the minimum element in the unsorted portion of the array starting from index i. We swap the element at index i with the minimum element found in step 3. We repeat steps 3-4 until the entire array is sorted. Complexity Analysis The time complexity of selection sort is O(n^2), where n is the length of the array. This is because we have to iterate over the entire array n times, and for each iteration, we have to find the minimum element in the unsorted portion of the array, which takes O(n) time. The space complexity of selection sort is O(1), because we only need to store a few variables to keep track of the indices and the temporary value during the swapping process. Selection sort is not very efficient for large arrays, but it has the advantage of being simple to implement and understand. It can also be useful in situations where memory is limited, since it only requires a constant amount of extra memory." />
<link rel="canonical" href="/blog/algorithm/2023/11/10/selection-sort.html" />
<meta property="og:url" content="/blog/algorithm/2023/11/10/selection-sort.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-10T19:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Selection Sort" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-10T19:00:00+02:00","datePublished":"2023-11-10T19:00:00+02:00","description":"Introduction Selection sort is a simple sorting algorithm that works by repeatedly finding the minimum element from an unsorted list and putting it at the beginning. The algorithm is not very efficient for large lists, but it has the advantage of being simple to understand and implement. Implementation Here is an implementation of selection sort in OCaml: let rec find_min i arr = if i = Array.length arr then -1 else let min_idx = find_min (i+1) arr in if min_idx = -1 || arr.(i) &lt; arr.(min_idx) then i else min_idx let selection_sort arr = for i = 0 to Array.length arr - 1 do let min_idx = find_min i arr in let tmp = arr.(i) in arr.(i) &lt;- arr.(min_idx); arr.(min_idx) &lt;- tmp done Here, find_min is a helper function that finds the index of the minimum element in the array arr starting from index i. It returns -1 if i is already at the end of the array. selection_sort uses find_min to find the minimum element in the unsorted portion of the array and swaps it with the first element in the unsorted portion. This process is repeated until the entire array is sorted. Here is an example of using selection_sort: let arr = [|5; 2; 9; 3; 6|] selection_sort arr (* arr is now [|2; 3; 5; 6; 9|] *) Step-by-step Explanation We start with an unsorted array arr. We iterate over the array from index 0 to n-1, where n is the length of the array. For each iteration, we call find_min to find the index of the minimum element in the unsorted portion of the array starting from index i. We swap the element at index i with the minimum element found in step 3. We repeat steps 3-4 until the entire array is sorted. Complexity Analysis The time complexity of selection sort is O(n^2), where n is the length of the array. This is because we have to iterate over the entire array n times, and for each iteration, we have to find the minimum element in the unsorted portion of the array, which takes O(n) time. The space complexity of selection sort is O(1), because we only need to store a few variables to keep track of the indices and the temporary value during the swapping process. Selection sort is not very efficient for large arrays, but it has the advantage of being simple to implement and understand. It can also be useful in situations where memory is limited, since it only requires a constant amount of extra memory.","headline":"Selection Sort","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/algorithm/2023/11/10/selection-sort.html"},"url":"/blog/algorithm/2023/11/10/selection-sort.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/blog/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Selection Sort</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-10T19:00:00+02:00" itemprop="datePublished">
        Nov 10, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>Selection sort is a simple sorting algorithm that works by repeatedly finding the minimum element from an unsorted list and putting it at the beginning. The algorithm is not very efficient for large lists, but it has the advantage of being simple to understand and implement.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of selection sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">find_min</span> <span class="n">i</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">if</span> <span class="n">i</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">then</span> <span class="o">-</span><span class="mi">1</span>  
  <span class="k">else</span>  
    <span class="k">let</span> <span class="n">min_idx</span> <span class="o">=</span> <span class="n">find_min</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">arr</span> <span class="k">in</span>  
    <span class="k">if</span> <span class="n">min_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">min_idx</span><span class="p">)</span> <span class="k">then</span> <span class="n">i</span> <span class="k">else</span> <span class="n">min_idx</span>  
   
<span class="k">let</span> <span class="n">selection_sort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>  
    <span class="k">let</span> <span class="n">min_idx</span> <span class="o">=</span> <span class="n">find_min</span> <span class="n">i</span> <span class="n">arr</span> <span class="k">in</span>  
    <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>  
    <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">min_idx</span><span class="p">);</span>  
    <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">min_idx</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">tmp</span>  
  <span class="k">done</span>  
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">find_min</code> is a helper function that finds the index of the minimum element in the array <code class="language-plaintext highlighter-rouge">arr</code> starting from index <code class="language-plaintext highlighter-rouge">i</code>. It returns <code class="language-plaintext highlighter-rouge">-1</code> if <code class="language-plaintext highlighter-rouge">i</code> is already at the end of the array. <code class="language-plaintext highlighter-rouge">selection_sort</code> uses <code class="language-plaintext highlighter-rouge">find_min</code> to find the minimum element in the unsorted portion of the array and swaps it with the first element in the unsorted portion. This process is repeated until the entire array is sorted.</p>

<p>Here is an example of using <code class="language-plaintext highlighter-rouge">selection_sort</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span><span class="mi">5</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">9</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">6</span><span class="o">|</span><span class="p">]</span>  
<span class="n">selection_sort</span> <span class="n">arr</span>  
<span class="c">(* arr is now [|2; 3; 5; 6; 9|] *)</span>  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>We start with an unsorted array <code class="language-plaintext highlighter-rouge">arr</code>.</li>
  <li>We iterate over the array from index <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n-1</code>, where <code class="language-plaintext highlighter-rouge">n</code> is the length of the array.</li>
  <li>For each iteration, we call <code class="language-plaintext highlighter-rouge">find_min</code> to find the index of the minimum element in the unsorted portion of the array starting from index <code class="language-plaintext highlighter-rouge">i</code>.</li>
  <li>We swap the element at index <code class="language-plaintext highlighter-rouge">i</code> with the minimum element found in step 3.</li>
  <li>We repeat steps 3-4 until the entire array is sorted.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of selection sort is O(n^2), where n is the length of the array. This is because we have to iterate over the entire array n times, and for each iteration, we have to find the minimum element in the unsorted portion of the array, which takes O(n) time. The space complexity of selection sort is O(1), because we only need to store a few variables to keep track of the indices and the temporary value during the swapping process.</p>

<p>Selection sort is not very efficient for large arrays, but it has the advantage of being simple to implement and understand. It can also be useful in situations where memory is limited, since it only requires a constant amount of extra memory.</p>

  </div><a class="u-url" href="/blog/algorithm/2023/11/10/selection-sort.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>A collection of classic algorithms, written in OCaml.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
